<!DOCTYPE html>
<html lang="ru">

  <head>
    <title>JSON-RPC на C++ &#x2F; Хабр</title>

































    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    

    
    
    
    
    
  </head>
  <body>
    
    <div id="mount"><div id="app"><div class="tm-layout__wrapper"><!--[--><!----><div></div><div class="header-banner-wrapper"><div class="element-wrapper above-header" style="--754c4550:100%;--56cb6579:auto;"><!--[--><div class="placeholder-wrapper banner-container__placeholder"><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="adfox-banner-placeholder above-header" data-v-24012b5e><div class="image loads" data-v-24012b5e></div><div class="lines" data-v-24012b5e><div class="line loads" data-v-24012b5e></div><div class="line loads" data-v-24012b5e></div><div class="line loads" data-v-24012b5e></div></div></div><!----><!----><!----></div><!--[--><div id="adfox_175449164307199013_aboveHeader" class="banner-target"></div><!--]--><!--]--></div></div><header class="tm-header tm-header" data-test-id="header"><!----><!----><div class="tm-page-width"><!--[--><div class="tm-header__container"><button aria-expanded="false" aria-label="Toggle menu" class="burger-button tm-header__button tm-header__burger" data-v-56ed7aae><span class="line top" data-v-56ed7aae></span><span class="line middle" data-v-56ed7aae></span><span class="line bottom" data-v-56ed7aae></span></button><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/feed"><svg class="tm-svg-img tm-header__icon" height="16" width="16"><title>Хабр</title><use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a></span><span class="tm-header__divider"></span><!--[--><a class="tm-header__all-flows" href="/ru/articles/">Все потоки</a><!--]--><!----><div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search" height="24" width="24"><title>Поиск</title><use xlink:href="/img/megazord-v28.cba4c116..svg#search"></use></svg></a><!----><!----><div class="tm-header-user-menu__item tm-header-user-menu__write"><a href="/ru/sandbox/start/" class=""><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write" height="24" width="24"><title>Написать публикацию</title><use xlink:href="/img/megazord-v28.cba4c116..svg#write"></use></svg></a><!----></div><!--[--><div class="tm-header-user-menu__item"><button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings"><svg class="tm-svg-img tm-header-user-menu__icon" height="24" width="24"><title>Настройки</title><use xlink:href="/img/megazord-v28.cba4c116..svg#page-settings"></use></svg></button></div><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/articles/312994/&amp;hl=ru" rel="nofollow" class="tm-header-user-menu__item tm-header-user-menu__login" role="button"><!--[-->Войти<!--]--></a><!--]--><template><!----></template><!--teleport start--><!--teleport end--></div></div><!--]--></div></header><div class="tm-layout"><div class="tm-page-progress-bar"></div><!----><div class="tm-page-width"><!--[--><!----><!----><!----><!--]--></div><main class="tm-layout__container"><div class="tm-page" hl="ru" data-async-called="true" style="--a414e232:300px;--10c4682a:0;--19620736:0;"><!----><div class="tm-page-width"><!--[--><!----><div class="tm-page__wrapper"><!----><div class="tm-page__main_has-sidebar tm-page__main"><div class="pull-down"><!----><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24"><title>Обновить</title><use xlink:href="/img/megazord-v28.cba4c116..svg#pull-arrow"></use></svg></div></div><!--[--><div><!--[--><!----><div class="tm-article-presenter" data-async-called="true"><!--[--><!--]--><div class="tm-article-presenter__body" data-test-id="article-body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><!--[--><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><!--[--><div class="tm-article-presenter__header"><!--[--><!--]--><div class="article-snippet tm-article-presenter__snippet" data-v-085cd854><!--[--><!--]--><div class="meta-container" data-v-085cd854><div class="meta" data-v-085cd854><span class="tm-user-info author" data-v-085cd854><a href="/ru/users/laphroaig/" class="tm-user-info__userpic" data-test-id="user-info-pic"><!--[--><div class="tm-entity-image"></div><!--]--></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a href="/ru/users/laphroaig/" class="tm-user-info__username" data-test-id="user-info-username"><!--[-->laphroaig<!--]--></a><!----><!--[--><span class="tm-article-datetime-published" data-v-085cd854><time data-allow-mismatch datetime="2016-10-26T08:15:40.000Z" title="2016-10-26, 08:15">26  окт  2016 в 08:15</time></span><!--]--></span></span></div><div class="controls" data-v-085cd854><!----><!----><!----><!----></div></div><h1 class="tm-title tm-title_h1" lang="ru" data-test-id="articleTitle" data-v-085cd854><span>JSON-RPC на C++</span></h1><div class="stats" data-test-id="articleStats" data-v-085cd854><!----><div class="tm-article-reading-time" data-v-085cd854><span class="tm-svg-icon__wrapper tm-article-reading-time__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Время на прочтение</title><use xlink:href="/img/megazord-v28.cba4c116..svg#clock"></use></svg></span><span class="tm-article-reading-time__label">33 мин</span></div><span class="tm-icon-counter tm-data-icons__item reach-counter" data-v-085cd854><svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24"><title>Охват и читатели</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-views"></use></svg><span class="tm-icon-counter__value" title="16519">17K</span></span></div><div class="tm-publication-hubs__container" data-test-id="articleHubsList" data-v-085cd854><div class="tm-publication-hubs"><!--[--><span class="tm-publication-hub__link-container"><a href="/ru/hubs/cpp/" class="tm-publication-hub__link"><!--[--><span>C++</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб"> * </span><!--]--></a></span><!--]--></div></div><div class="tm-article-labels" data-test-id="articleLabels" data-v-085cd854 data-v-bfa2437b><div class="tm-article-labels__container" data-v-bfa2437b><!----><!--[--><!----><!--[--><!--]--><!--]--></div></div><!----><!----><!--teleport start--><!--teleport end--></div></div><!--[--><!----><div class="article-body" data-gallery-root lang="ru" data-v-aad06d04><div data-v-aad06d04><!--[--><!--]--></div><div id="post-content-body" data-v-aad06d04><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p>В предыдущей <a href="https://habrahabr.ru/post/311262/">статье</a> про декларативный JSON-сериализатор я рассказал, как с помощью шаблонов C++ можно описывать структуры данных и сериализовать их. Это очень удобно, т.к. не только сокращает размер кода, но и минимизирует количество возможных ошибок.Концепция — если код компилируется, то он работает. Примерно такой же подход применен и в wjrpc, о которой речь пойдет в этой статье. Но поскольку wjrpc “выдран” из фреймворка, под интерфейсы которого он был разработан, я также затрону вопросы архитектуры и асинхронных интерфейсов.</p><br/>
<a name="habracut"></a><br/>
<p>Я не буду описывать JSON-сериализатор, на котором работает wjrpc и с помощью которого осуществляется JSON-описание для структур данных сообщений. Про <a href="https://github.com/mambaru/wjson">wjson</a> я рассказал в предыдущей статье. Прежде чем рассматривать декларативный вариант описания API сервисов для JSON-RPC, рассмотрим, как можно реализовать разбор в “вручную”. Это потребует написания большего количества run-time кода по извлечению данных и проверок, но он проще для понимания. Все примеры вы можете найти в разделе examples проекта.</p><br/>
<p>В качестве примера рассмотрим API простого калькулятора, который может выполнять операции сложения, вычитания, умножения и деления. Сами запросы тривиальны, поэтому приведу только код только для операции сложения:</p><br/>
<div class="spoiler"><b class="spoiler_title">calc/api/plus.hpp</b><div class="spoiler_text"><pre><code class="cpp">#pragma once
#include &lt;memory&gt;
#include &lt;functional&gt;

namespace request
{
    struct plus
    {
        int first=0;
        int second=0;
        typedef std::unique_ptr&lt;plus&gt; ptr;
    };
} // request

namespace response
{
    struct plus
    {
        int value=0;
        typedef std::unique_ptr&lt;plus&gt; ptr;
        typedef std::function&lt;void(ptr)&gt; callback;
    };
} // response</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Я предпочитаю структуры для каждой пары запрос-ответ размещать в отдельном файле в специально отведенной для этого папке. Это здорово облегчает навигацию по проекту. Использование пространств имен и определение вспомогательных типов, как показано в примере выше, не обязательно, но повышает читабельность кода. Смысл этих typedef-ов поясню позднее.</p><br/>
<p>Для каждого запроса создаем описание JSON.</p><br/>
<div class="spoiler"><b class="spoiler_title">calc/api/plus_json.hpp</b><div class="spoiler_text"><pre><code class="cpp">#pragma once
#include "calc/api/plus.hpp"
#include &lt;wjson/json.hpp&gt;
#include &lt;wjson/name.hpp&gt;

namespace request
{
    struct plus_json
    {
        JSON_NAME(first)
        JSON_NAME(second)

        typedef wjson::object&lt;
            plus,
            wjson::member_list&lt;
                wjson::member&lt;n_first, plus, int, &amp;plus::first&gt;,
                wjson::member&lt;n_second, plus, int, &amp;plus::second&gt;
            &gt;
        &gt; type;
        typedef typename type::serializer serializer;
        typedef typename type::target target;
    };
}

namespace response
{
    struct plus_json
    {
        JSON_NAME(value)
        typedef wjson::object&lt;
            plus,
            wjson::member_list&lt;
                wjson::member&lt;n_value, plus, int, &amp;plus::value&gt;
            &gt;
        &gt; type;
        typedef typename type::serializer serializer;
        typedef typename type::target target;
    };
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Зачем помещать его в структуру, я рассказывал в статье, посвященной wjson. Отмечу только, что здесь определения typedef-ов требуется, чтобы эти структуры были распознаны как json-описание.</p><br/>
<p>Обработку JSON-RPC сообщений можно разделить на два этапа. На первом этапе нужно определить тип запроса и имя метода, а на втором десериализовать параметры для этого метода.</p><br/>
<div class="spoiler"><b class="spoiler_title">Сериализованный JSON-RPC для plus</b><div class="spoiler_text"><pre><code>&lt;p&gt;{
"jsonrpc":"2.0",
"method":"plus",
"params":{
"first":2,
"second":3
},
"id":1
}&lt;/p&gt;
&lt;source&gt;&lt;!--&lt;/spoiler&gt;--&gt;
Например, на первом этапе можно сериализовать запросы в такую структуру:
&lt;!--&lt;spoiler title="Структура для запросов"&gt;--&gt;
```cpp
struct request
{
    std::string version,
    std::string method,
    std::string params,
    std::string id
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<div class="spoiler"><b class="spoiler_title">JSON-описание для запросов</b><div class="spoiler_text"><pre><code class="cpp">JSON_NAME(jsonrpc)
JSON_NAME(method)
JSON_NAME(params)
JSON_NAME(id)

typedef wjson::object&lt;
    request,
    wjson::member_list&lt;
        wjson::member&lt;n_jsonrpc, request, std::string, &amp;request::version&gt;,
        wjson::member&lt;n_method, request, std::string, &amp;request::method&gt;,
        wjson::member&lt;n_params, request, std::string, &amp;request::params, json::raw_value&lt;&gt; &gt;,
        wjson::member&lt;n_id, request, std::string, &amp;request::id, json::raw_value&lt;&gt; &gt;
    &gt;
&gt; request_json;</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>При таком описании в поля <code>request::params</code> и <code>request::id</code> json будет скопирован как есть, без какого-либо преобразования, а в поле <code>request::method</code> будет собственно имя метода. Определив имя метода, можем десериализовать параметры описанными выше структурами.</p><br/>
<p>Чтобы определить имя метода, не обязательно десериализовать весь запрос в промежуточную структуру данных. Достаточно его распарсить, а десериализовать только кусок запроса, относящийся к полю params. Это можно сделать с помощью wjson::parser напрямую, но wjson предоставляет также конструкцию raw_pair (в предыдущей статье я ее не рассматривал), которая позволит не десериализовать элементы, а запомнить его расположение во входном буфере. Рассмотрим, как это реализовано в wjrpc.</p><br/>
<p>Начнем с того, что wjrpc не работает со строками std::string, а определяет следующие типы:</p><br/>
<pre><code class="cpp">namespace wjrpc
{
    typedef std::vector&lt;char&gt; data_type;
    typedef std::unique_ptr&lt;data_type&gt; data_ptr;
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Можно рассматривать data_ptr как перемещаемый буфер, использование которого позволяет нам гарантировать, что данные лишний раз не будут скопированы по недосмотру.</p><br/>
<p>Любое входящее сообщение wjrpc попытается десериализовать в следующую структуру:</p><br/>
<div class="spoiler"><b class="spoiler_title">wjrpc::incoming</b><div class="spoiler_text"><pre><code class="cpp">namespace wjrpc
{
    struct incoming
    {
        typedef data_type::iterator iterator;
        typedef std::pair&lt;iterator, iterator&gt; pair_type;
        pair_type method;
        pair_type params;
        pair_type result;
        pair_type error;
        pair_type id;
    };
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Все элементы wjrpc::incoming представляют собой пары итераторов во входном буфере. Например, method.first при десериализации будет указывать на кавычку, которая открывает имя метода, после двоеточия, во входном запросе, а method.second — на следующую позицию после закрывающей кавычки. Эта структура описывает также не только запрос, но и ответ на запрос, а также сообщение об ошибке. Определить тип сообщения достаточно просто по заполненным полям. JSON -описание для такой структуры:</p><br/>
<div class="spoiler"><b class="spoiler_title">wjrpc::incoming_json</b><div class="spoiler_text"><pre><code class="cpp">namespace wjrpc
{
    struct incoming_json
    {
        typedef incoming::pair_type pair_type;
        typedef wjson::iterator_pair&lt;pair_type&gt; pair_json;

        JSON_NAME(id)
        JSON_NAME(method)
        JSON_NAME(params)
        JSON_NAME(result)
        JSON_NAME(error)

        typedef wjson::object&lt;
            incoming,
            wjson::member_list&lt;
                wjson::member&lt;n_method, incoming, pair_type, &amp;incoming::method, pair_json&gt;,
                wjson::member&lt;n_params, incoming, pair_type, &amp;incoming::params, pair_json&gt;,
                wjson::member&lt;n_result, incoming, pair_type, &amp;incoming::result, pair_json&gt;,
                wjson::member&lt;n_error, incoming, pair_type, &amp;incoming::error, pair_json&gt;,
                wjson::member&lt;n_id, incoming, pair_type, &amp;incoming::id, pair_json&gt;
            &gt;
        &gt; type;

        typedef type::target target;
        typedef type::member_list member_list;
        typedef type::serializer serializer;
    };
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Здесь нет полноценной десериализации — это по сути парсинг с запоминанием позиций во входном буфере. Очевидно, что после такой десериализации данные будут валидны, только пока существует входной буфер.</p><br/>
<p>Класс wjrpc::incoming_holder захватывает буфер с запросом и парсит его в описанную выше структуру. Я не буду подробно описывать его интерфейс, но покажу, как можно его использовать для реализации JSON-RPC.</p><br/>
<div class="spoiler"><b class="spoiler_title">Сначала упрощенный пример с одним методом</b><div class="spoiler_text"><pre><code class="cpp">#include "calc/api/plus.hpp"
#include "calc/api/plus_json.hpp"

#include &lt;wjrpc/errors/error_json.hpp&gt;
#include &lt;wjrpc/incoming/incoming_holder.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_holder.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_result.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_result_json.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_error.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_error_json.hpp&gt;

#include &lt;iostream&gt;

int main()
{
    std::vector&lt;std::string&gt; req_list =
    {
        "{\"method\":\"plus\", \"params\":{ \"first\":2, \"second\":3 }, \"id\" :1 }",
        "{\"method\":\"minus\", \"params\":{ \"first\":5, \"second\":10 }, \"id\" :1 }",
        "{\"method\":\"multiplies\", \"params\":{ \"first\":2, \"second\":2 }, \"id\" :1 }",
        "{\"method\":\"divides\", \"params\":{ \"first\":9, \"second\":3 }, \"id\" :1 }"
    };
    std::vector&lt;std::string&gt; res_list;

    for ( auto&amp; sreq : req_list )
    {
        wjrpc::incoming_holder inholder( sreq );
        // Парсим без проверок на ошибки
        inholder.parse(nullptr);

        // Есть имя метода и идентификатор вызова
        if ( inholder.method() == "plus" )
        {
            // Десериализация параметров без проверок
            auto params = inholder.get_params&lt;request::plus_json&gt;(nullptr);
            // Объект для ответа
            wjrpc::outgoing_result&lt;response::plus&gt; res;
            res.result = std::make_unique&lt;response::plus&gt;();

            // Выполняем операцию
            res.result-&gt;value = params-&gt;first + params-&gt;second;
            // Забираем id в сыром виде как есть
            auto raw_id = inholder.raw_id();
            res.id = std::make_unique&lt;wjrpc::data_type&gt;( raw_id.first, raw_id.second );
            // Сериализатор ответа
            typedef wjrpc::outgoing_result_json&lt;response::plus_json&gt; result_json;
            res_list.push_back(std::string());
            result_json::serializer()( res, std::back_inserter(res_list.back()) );
        }
        /* else if ( inholder.method() == "minus" ) { ... } */
        /* else if ( inholder.method() == "multiplies" ) { ... } */
        /* else if ( inholder.method() == "divides" ) { ... } */
    }

    for ( size_t i =0; i != res_list.size(); ++i)
    {
        std::cout &lt;&lt; req_list[i] &lt;&lt; std::endl;
        std::cout &lt;&lt; res_list[i] &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
    }
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Здесь большую часть кода занимает формирование ответа, потому что не делаем проверок на ошибки. Сначала инициализируем incoming_holder строкой и парсим ее. На этом этапе входная строка десериализуется в описанную выше структуру incoming. Если строка содержит любой валидный json-объект, то этот этап пройдет без ошибок.</p><br/>
<p>Далее нужно определить тип запроса. Это легко сделать по наличию или отсутствию полей “method”, “result”, “error” и “id”.</p><br/>
<table>
<thead>
<tr>
<th>Комбинация</th>
<th>Тип сообщения</th>
<th>Проверка</th>
<th>Получить</th>
</tr>
</thead>
<tbody>
<tr>
<td>method и id</td>
<td>запрос</td>
<td>is_request</td>
<td>get_params&lt;&gt;</td>
</tr>
<tr>
<td>method без id</td>
<td>уведомление</td>
<td>is_notify</td>
<td>get_params&lt;&gt;</td>
</tr>
<tr>
<td>result и id</td>
<td>ответ на запрос</td>
<td>is_response</td>
<td>get_result&lt;&gt;</td>
</tr>
<tr>
<td>error и id</td>
<td>ошибка в ответ на запрос</td>
<td>is_request_error</td>
<td>get_error&lt;&gt;</td>
</tr>
<tr>
<td>error без id</td>
<td>прочие ошибки</td>
<td>is_other_error</td>
<td>get_error&lt;&gt;</td>
</tr>
</tbody>
</table><br/>
<p>Если не выполняется ни одно из условий, то очевидно, что запрос неправильный.</p><br/>
<div class="spoiler"><b class="spoiler_title">Пример с проверками и одним методом</b><div class="spoiler_text"><pre><code class="cpp">#include "calc/api/plus.hpp"
#include "calc/api/plus_json.hpp"

#include &lt;wjrpc/errors/error_json.hpp&gt;
#include &lt;wjrpc/incoming/incoming_holder.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_holder.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_result.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_result_json.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_error.hpp&gt;
#include &lt;wjrpc/outgoing/outgoing_error_json.hpp&gt;
#include &lt;iostream&gt;

int main()
{
    std::vector&lt;std::string&gt; req_list =
    {
        "{\"method\":\"plus\", \"params\":{ \"first\":2, \"second\":3 }, \"id\" :1 }",
        "{\"method\":\"minus\", \"params\":{ \"first\":5, \"second\":10 }, \"id\" :1 }",
        "{\"method\":\"multiplies\", \"params\":{ \"first\":2, \"second\":2 }, \"id\" :1 }",
        "{\"method\":\"divides\", \"params\":{ \"first\":9, \"second\":3 }, \"id\" :1 }"
    };
    std::vector&lt;std::string&gt; res_list;

    for ( auto&amp; sreq : req_list )
    {
        wjrpc::incoming_holder inholder( sreq );
        wjson::json_error e;
        inholder.parse(&amp;e);
        if ( e )
        {
            typedef wjrpc::outgoing_error&lt;wjrpc::error&gt; error_type;
            error_type err;
            err.error = std::make_unique&lt;wjrpc::parse_error&gt;();

            typedef wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json;
            std::string str;
            error_json::serializer()(err, std::back_inserter(str));
            res_list.push_back(str);
        }
        else if ( inholder.is_request() )
        {
            auto raw_id = inholder.raw_id();
            auto call_id = std::make_unique&lt;wjrpc::data_type&gt;( raw_id.first, raw_id.second );
            // Есть имя метода и идентификатор вызова
            if ( inholder.method() == "plus" )
            {
                auto params = inholder.get_params&lt;request::plus_json&gt;(&amp;e);
                if ( !e )
                {
                    wjrpc::outgoing_result&lt;response::plus&gt; res;
                    res.result = std::make_unique&lt;response::plus&gt;();
                    res.result-&gt;value = params-&gt;first + params-&gt;second;
                    res.id = std::move(call_id);
                    typedef wjrpc::outgoing_result_json&lt;response::plus_json&gt; result_json;
                    std::string str;
                    result_json::serializer()( res, std::back_inserter(str) );
                    res_list.push_back(str);
                }
                else
                {
                    typedef wjrpc::outgoing_error&lt;wjrpc::error&gt; error_type;
                    error_type err;
                    err.error = std::make_unique&lt;wjrpc::invalid_params&gt;();
                    err.id = std::move(call_id);

                    typedef wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json;
                    std::string str;
                    error_json::serializer()(err, std::back_inserter(str));
                    res_list.push_back(str);
                }
            }
            /* else if ( inholder.method() == "minus" ) { ... } */
            /* else if ( inholder.method() == "multiplies" ) { ... } */
            /* else if ( inholder.method() == "divides" ) { ... } */
            else
            {
                typedef wjrpc::outgoing_error&lt;wjrpc::error&gt; error_type;
                error_type err;
                err.error = std::make_unique&lt;wjrpc::procedure_not_found&gt;();
                err.id = std::move(call_id);

                typedef wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json;
                std::string str;
                error_json::serializer()(err, std::back_inserter(str));
                res_list.push_back(str);
            }
        }
        else
        {
            typedef wjrpc::outgoing_error&lt;wjrpc::error&gt; error_type;
            error_type err;
            err.error = std::make_unique&lt;wjrpc::invalid_request&gt;();

            typedef wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json;
            std::string str;
            error_json::serializer()(err, std::back_inserter(str));
            res_list.push_back(str);
        }
    }

    for ( size_t i =0; i != res_list.size(); ++i)
    {
        std::cout &lt;&lt; req_list[i] &lt;&lt; std::endl;
        std::cout &lt;&lt; res_list[i] &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
    }
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Здесь большая часть кода — это обработка ошибок, а точнее, формирования соответствующего сообщения. Но для всех типов ошибок код похожий, отличия только в типе ошибки. Можно сделать одну шаблонную функцию для сериализации всех типов ошибок.</p><br/>
<div class="spoiler"><b class="spoiler_title">Формирование сообщения об ошибке</b><div class="spoiler_text"><pre><code class="cpp">template&lt;typename E&gt;
void make_error(wjrpc::incoming_holder inholder, std::string&amp; out)
{
    typedef wjrpc::outgoing_error&lt;wjrpc::error&gt; common_error;
    common_error err;
    err.error = std::make_unique&lt;E&gt;();
    if ( inholder.has_id() )
    {
        auto id = inholder.raw_id();
        err.id = std::make_unique&lt;wjrpc::data_type&gt;(id.first, id.second);
    }

    typedef wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json;
    error_json::serializer()(err, std::back_inserter(out));
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Для формирования сообщения об ошибке нам достаточно знать тип ошибки и идентификатор вызова, если он есть. Объект inholder перемещаемый и после формирования сообщения он больше не нужен. В примере он используется только для извлечения идентификатора вызова, но у него также можно “забрать” входной буфер — для сериализации туда сообщения, чтобы не создавать новый.</p><br/>
<p>Аналогичным образом можно и реализовать сериализацию результата. Но прежде чем продолжить избавляться от однотипного кода, приведем в порядок прикладную часть, которая здесь несколько затерялась и представлена всего одной строкой для каждого метода.</p><br/>
<h2 id="interfeysy">Интерфейсы</h2><br/>
<p>Как я уже говорил, wjrpc выдран из фреймворка, в котором для компонентов нужно явно определять интерфейс. Причем, это не просто структура исключительно с чистыми виртуальными методами, но и предъявляются определенные ограничения к параметрам методов.</p><br/>
<p>Все входные и выходные параметры должны быть объединены в структуры, даже если там будет только одно поле. Это удобно не только для формирования json-описания для запроса, когда десериализованную структуру можем передать напрямую в метод, без предварительного преобразования, но и с позиции расширяемости.</p><br/>
<p>Например, во всех методах мы возвращаем число — результат выполнения операции. Смысл описывать результат структурой с одним полем, если можно числом? А входные параметры вообще можно было передать массивом (позиционными параметрами).</p><br/>
<p>Но теперь представьте, что требования немного изменились, и к списку параметров нужно добавить сопроводительную информацию, либо в ответе, для операции деления, флаг, означающий, что произошло деление на ноль. В этом случае для внесения исправлений нужно “перетряхнуть” не только интерфейс и все его реализации, но и все места, где он используется.</p><br/>
<p>Если у нас JSON-RPC сервис, то изменения коснутся не только сервера, но и клиента, интерфейсы которых нужно как-то согласовывать. А в случае со структурами достаточно просто добавить поле в структуру. Причем, обновлять клиентскую часть и серверную часть можно независимо.</p><br/>
<p>Еще одна особенность фреймворка в том, что все методы имеют асинхронный интерфейс, т.е. результат возвращается не напрямую, а через функцию обратного вызова. А чтобы избежать ошибок непреднамеренного копирования, входной и выходной объект описывается как std::unique_ptr&lt;&gt;.</p><br/>
<p>Для нашего калькулятора, с учетом описанных ограничений, получается вот такой интерфейс:</p><br/>
<pre><code class="cpp">struct icalc
{
    virtual ~icalc() {}
    virtual void plus( request::plus::ptr req, response::plus::callback cb) = 0;
    virtual void minus( request::minus::ptr req, response::minus::callback cb) = 0;
    virtual void multiplies( request::multiplies::ptr req, response::multiplies::callback cb) = 0;
    virtual void divides( request::divides::ptr req, response::divides::callback cb) = 0;
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>С учетом вспомогательных typedef-ов, которые мы определили во входных структурах, выглядит вполне симпатично. Но вот реализация для подобных интерфейсов может быть достаточно объемной относительно простых примеров. Нужно удостовериться, что входной запрос не nullptr, а также проверить функцию обратного вызова. Если она не определена, то очевидно, что это уведомление, и в данном случае вызов нужно просто проигнорировать. Этот функционал легко шаблонизировать, как показано в примере реализации нашего калькулятора</p><br/>
<div class="spoiler"><b class="spoiler_title">calc1.hpp</b><div class="spoiler_text"><pre><code class="cpp">#pragma once
#include "icalc.hpp"

class calc1
: public icalc
{
public:
    virtual void plus( request::plus::ptr req, response::plus::callback cb) override;
    virtual void minus( request::minus::ptr req, response::minus::callback cb) override;
    virtual void multiplies( request::multiplies::ptr req, response::multiplies::callback cb) override;
    virtual void divides( request::divides::ptr req, response::divides::callback cb) override;
private:
    template&lt;typename Res, typename ReqPtr, typename Callback, typename F&gt;
    void impl_( ReqPtr req, Callback cb, F f);
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<div class="spoiler"><b class="spoiler_title">calc1.cpp</b><div class="spoiler_text"><pre><code class="cpp">#include "calc1.hpp"
#include &lt;wjrpc/memory.hpp&gt;

template&lt;typename Res, typename ReqPtr, typename Callback, typename F&gt;
void calc1::impl_( ReqPtr req, Callback cb, F f)
{
    // это уведомление
    if ( cb == nullptr )
        return;

    // нет параметров
    if ( req == nullptr )
        return cb(nullptr);

    auto res = std::make_unique&lt;Res&gt;();
    res-&gt;value = f(req-&gt;first,req-&gt;second);
    cb( std::move(res) );
}

void calc1::plus( request::plus::ptr req, response::plus::callback cb)
{
    this-&gt;impl_&lt;response::plus&gt;( std::move(req), cb, [](int f, int s) { return f+s; } );
}

void calc1::minus( request::minus::ptr req, response::minus::callback cb)
{
    this-&gt;impl_&lt;response::minus&gt;( std::move(req), cb, [](int f, int s) { return f-s; });
}

void calc1::multiplies( request::multiplies::ptr req, response::multiplies::callback cb)
{
    this-&gt;impl_&lt;response::multiplies&gt;( std::move(req), cb, [](int f, int s) { return f*s; });
}

void calc1::divides( request::divides::ptr req, response::divides::callback cb)
{
    this-&gt;impl_&lt;response::divides&gt;( std::move(req), cb, [](int f, int s) { return s!=0 ? f/s : 0; });
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Статья все же не про реализацию калькулятора, поэтому представленный выше код не стоит воспринимать как best practice. Пример вызова метода:</p><br/>
<pre><code class="cpp">calc-&gt;plus( std::move(params), [](response::plus::ptr result) { … });</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>К теме интерфейсов еще вернемся, а сейчас продолжим “сокращать” код нашего сервиса. Для того, чтобы асинхронно сериализовать результат, необходимо “захватить” входящий запрос</p><br/>
<div class="spoiler"><b class="spoiler_title">например, так</b><div class="spoiler_text"><pre><code class="cpp">std::shared_ptr&lt;wjrpc::incoming_holder&gt; ph = std::make_shared&lt;wjrpc::incoming_holder&gt;( std::move(inholder) );
calc-&gt;plus( std::move(params), [ph, &amp;res_list](response::plus::ptr result)
{
    // Создаем объект результата
    wjrpc::outgoing_result&lt;response::plus&gt; resp;
    resp.result = std::move(result);
    // инициализируем идентификатор вызова
    auto raw_id = ph-&gt;raw_id();
    auto call_id = std::make_unique&lt;wjrpc::data_type&gt;( raw_id.first, raw_id.second );
    resp.id = std::move(call_id);

    // Сериализуем результат
    typedef wjrpc::outgoing_result_json&lt;response::plus_json&gt; result_json;
    typedef wjrpc::outgoing_result_json&lt;response::plus_json&gt; result_json;
    // забираем буфер
    auto d = ph-&gt;detach();
    d-&gt;clear();
    result_json::serializer()( resp, std::back_inserter(d) );
    res_list.push_back( std::string(d-&gt;begin(), d-&gt;end()) );
});</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Т.к. incoming_holder перемещаемый, то чтобы его “захватить”, перемещаем его в std::shared_ptr. Здесь показано, как можно забрать у него буфер, но в данном случае это не имеет особого смысла — все равно результат помещаем в список строк. Захват res_list по ссылке — это только для примера, т.к. знаем, что запрос будет выполнен синхронно.</p><br/>
<p>Мы уже написали шаблонную функцию для сериализации ошибок, сделаем аналогичную для ответов. Но для этого, кроме типа результата, нужно передать его значение и json-описание.</p><br/>
<div class="spoiler"><b class="spoiler_title">Универсальный сериализатор ответа на запрос</b><div class="spoiler_text"><pre><code class="cpp">template&lt;typename ResJ&gt;
void send_response(std::shared_ptr&lt;wjrpc::incoming_holder&gt; ph, typename ResJ::target::ptr result, std::string&amp; out)
{
    typedef ResJ result_json;
    typedef typename result_json::target result_type;
    wjrpc::outgoing_result&lt;result_type&gt; resp;
    resp.result = std::move(result);
    auto raw_id = ph-&gt;raw_id();
    resp.id = std::make_unique&lt;wjrpc::data_type&gt;( raw_id.first, raw_id.second );
    typedef wjrpc::outgoing_result_json&lt;result_json&gt; response_json;
    typename response_json::serializer()( resp, std::back_inserter( out ) );
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Здесь шаблонный параметр нужно указывать явно — это json-описание для структуры ответа, из которого можно взять тип описываемой структуры. С использованием этой функции код для каждого JSON-RPC метода существенно упростится</p><br/>
<div class="spoiler"><b class="spoiler_title">Новая версия метода plus</b><div class="spoiler_text"><pre><code class="cpp">if ( inholder.method() == "plus" )
{
    // Ручная обработка
    auto params = inholder.get_params&lt;request::plus_json&gt;(&amp;e);
    if ( !e )
    {
        std::shared_ptr&lt;wjrpc::incoming_holder&gt; ph = std::make_shared&lt;wjrpc::incoming_holder&gt;( std::move(inholder) );
        calc-&gt;plus( std::move(params), std::bind( send_response&lt;response::plus_json&gt;, ph, std::placeholders::_1, std::ref(out)) );
    }
    else
    {
        make_error&lt;wjrpc::invalid_params&gt;(std::move(inholder), out );
    }
}
// else if ( inholder.method() == "minus" ) { ... }
// else if ( inholder.method() == "multiplies" ) { .... }
// else if ( inholder.method() == "divides" ) { .... }
else
{
    make_error&lt;wjrpc::procedure_not_found&gt;(std::move(inholder), out );
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Для каждого метода код сократился до минимума, но и этого мне мало. Получение параметров и проверка на ошибку — тоже однотипный код.</p><br/>
<div class="spoiler"><b class="spoiler_title">Сериализация и вызов метода</b><div class="spoiler_text"><pre><code class="cpp">template&lt;
typename JParams,
typename JResult,
void (icalc::*mem_ptr)(
    std::unique_ptr&lt;typename JParams::target&gt;,
    std::function&lt; void(std::unique_ptr&lt;typename JResult::target&gt;) &gt;
)
&gt;
void invoke(wjrpc::incoming_holder inholder, std::shared_ptr&lt;icalc&gt; calc, std::string&amp; out)
{
    typedef JParams params_json;
    typedef JResult result_json;
    wjson::json_error e;
    auto params = inholder.get_params&lt;params_json&gt;(&amp;e);
    if ( !e )
    {
        std::shared_ptr&lt;wjrpc::incoming_holder&gt; ph = std::make_shared&lt;wjrpc::incoming_holder&gt;( std::move(inholder) );
        (calc.get()-&gt;*mem_ptr)( std::move(params), std::bind( send_response&lt;result_json&gt;, ph, std::placeholders::_1, std::ref(out) ) );
    }
    else
    {
        out = make_error&lt;wjrpc::invalid_params&gt;();
    }
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Это уже почти так, как реализовано в wjrpc. В результате код демо примера сократится до минимума (здесь уже можно привести реализацию всех методов)</p><br/>
<div class="spoiler"><b class="spoiler_title">Конечный вариант примера с ‘ручной обработкой’</b><div class="spoiler_text"><pre><code class="cpp">int main()
{
    std::vector&lt;std::string&gt; req_list =
    {
        "{\"method\":\"plus\", \"params\":{ \"first\":2, \"second\":3 }, \"id\" :1 }",
        "{\"method\":\"minus\", \"params\":{ \"first\":5, \"second\":10 }, \"id\" :1 }",
        "{\"method\":\"multiplies\", \"params\":{ \"first\":2, \"second\":2 }, \"id\" :1 }",
        "{\"method\":\"divides\", \"params\":{ \"first\":9, \"second\":3 }, \"id\" :1 }"
    };
    std::vector&lt;std::string&gt; res_list;
    auto calc = std::make_shared&lt;calc1&gt;();
    for ( auto&amp; sreq : req_list )
    {
        res_list.push_back( std::string() );
        std::string&amp; out = res_list.back();
        wjrpc::incoming_holder inholder( sreq );
        wjson::json_error e;
        inholder.parse(&amp;e);
        if ( e )
        {
            out = make_error&lt;wjrpc::parse_error&gt;();
        }
        else if ( inholder.is_request() )
        {
            // Есть имя метода и идентификатор вызова
            if ( inholder.method() == "plus" )
            {
                invoke&lt;request::plus_json, response::plus_json, &amp;icalc::plus&gt;( std::move(inholder), calc, out );
            }
            else if ( inholder.method() == "minus" )
            {
                invoke&lt;request::minus_json, response::minus_json, &amp;icalc::minus&gt;( std::move(inholder), calc, out );
            }
            else if ( inholder.method() == "multiplies" )
            {
                invoke&lt;request::multiplies_json, response::multiplies_json, &amp;icalc::multiplies&gt;( std::move(inholder), calc, out );
            }
            else if ( inholder.method() == "divides" )
            {
                invoke&lt;request::divides_json, response::divides_json, &amp;icalc::divides&gt;( std::move(inholder), calc, out );
            }
            else
            {
                out = make_error&lt;wjrpc::procedure_not_found&gt;();
            }
        }
        else
        {
            out = make_error&lt;wjrpc::invalid_request&gt;();
        }
    }

    for ( size_t i =0; i != res_list.size(); ++i)
    {
        std::cout &lt;&lt; req_list[i] &lt;&lt; std::endl;
        std::cout &lt;&lt; res_list[i] &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
    }
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Такое маниакальное желание сократить run-time объем кода обусловлено несколькими причинами. Убирая лишний <code>if</code> с помощью достаточно сложной конструкции, мы не только сокращаем объем кода, но и убираем потенциальные места, где программисту будет в радость наговнокодить. А еще программисты любят копипастить, особенно неинтересный код, связанный сериализацией, размазывая его по всему проекту, а то и привнося в другие проекты. Лень — двигатель прогресса, когда она заставляет придумывать человека то, что позволит ему меньше работать. Но не в том случае, когда дела откладываются на потом. Казалось бы, тривиальная проверка, но со словами — это же пока прототип, написание пары строк кода откладывается, потом забывается и одновременно копипастится по всему проекту, а также подхватывается другими программистами.</p><br/>
<p>На самом деле мы еще не начали рассматривать wjrpc. Я показал, как описываются запросы с помощью wjson, описал интерфейс и прикладную логику тестового примера, и рассмотрел, как можно было бы реализовать JSON-RPC вручную, чтобы было понимание, как он работает изнутри и почему. А вот полный пример на wjrpc:</p><br/>
<pre><code class="cpp">#include "calc/calc1.hpp"
#include "calc/api/plus_json.hpp"
#include "calc/api/minus_json.hpp"
#include "calc/api/multiplies_json.hpp"
#include "calc/api/divides_json.hpp"

#include &lt;wjrpc/handler.hpp&gt;
#include &lt;wjrpc/method.hpp&gt;

#include &lt;iostream&gt;
#include &lt;functional&gt;

JSONRPC_TAG(plus)
JSONRPC_TAG(minus)
JSONRPC_TAG(multiplies)
JSONRPC_TAG(divides)

struct method_list: wjrpc::method_list
&lt;
    wjrpc::target&lt;icalc&gt;,
    wjrpc::invoke_method&lt;_plus_, request::plus_json, response::plus_json, icalc, &amp;icalc::plus&gt;,
    wjrpc::invoke_method&lt;_minus_, request::minus_json, response::minus_json, icalc, &amp;icalc::minus&gt;,
    wjrpc::invoke_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json, icalc, &amp;icalc::multiplies&gt;,
    wjrpc::invoke_method&lt;_divides_, request::divides_json, response::divides_json, icalc, &amp;icalc::divides&gt;
&gt;{};

class handler: public wjrpc::handler&lt;method_list&gt; {};

int main()
{
    std::vector&lt;std::string&gt; req_list =
    {
        "{\"method\":\"plus\", \"params\":{ \"first\":2, \"second\":3 }, \"id\" :1 }",
        "{\"method\":\"minus\", \"params\":{ \"first\":5, \"second\":10 }, \"id\" :1 }",
        "{\"method\":\"multiplies\", \"params\":{ \"first\":2, \"second\":2 }, \"id\" :1 }",
        "{\"method\":\"divides\", \"params\":{ \"first\":9, \"second\":3 }, \"id\" :1 }"
    };
    std::vector&lt;std::string&gt; res_list;

    auto calc = std::make_shared&lt;calc1&gt;();
    handler h;
    handler::options_type opt;
    opt.target = calc;
    h.start(opt, 1);

    for ( auto&amp; sreq : req_list )
    {
        h.perform( sreq, [&amp;res_list](std::string out) { res_list.push_back(out);} );
    }

    for ( size_t i =0; i != res_list.size(); ++i)
    {
        std::cout &lt;&lt; req_list[i] &lt;&lt; std::endl;
        std::cout &lt;&lt; res_list[i] &lt;&lt; std::endl;
        std::cout &lt;&lt; std::endl;
    }
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>С помощью JSONRPC_TAG задаются имена методов для передачи в качестве шаблонных параметров, аналогично JSON<em>NAME в wjson, разница только в именах сущностей, которые вместо префикса n</em>, обрамляются символами подчеркивания.</p><br/>
<p>Далее с помощью wjrpc::method_list и wjrpc::invoke_method описываем все доступные методы. Список методов передаем в обработчик wjrpc::handler. Наряду с методами в списке был описан тип интерфейса объекта, с которым обработчик будет работать.</p><br/>
<p>Основным методом обработки является perform_io, который работает с wjrpc::data_ptr.</p><br/>
<div class="spoiler"><b class="spoiler_title">Для строк сделана соответствующая обертка</b><div class="spoiler_text"><pre><code class="cpp">typedef std::vector&lt;char&gt; data_type;
typedef std::unique_ptr&lt;data_type&gt; data_ptr;
typedef std::function&lt; void(data_ptr) &gt; output_handler_t;

void perform_io(data_ptr d, output_handler_t handler) { … }
void perform(std::string str, std::function&lt;void(std::string)&gt; handler)
{
    auto d = std::make_unique&lt;data_type&gt;( str.begin(), str.end() );
    this-&gt;perform_io( std::move(d), [handler](data_ptr d)
    {
        handler( std::string(d-&gt;begin(), d-&gt;end()) );
    });
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Очевидно, что для синхронных серверов асинхронный интерфейс абсолютно не нужен. В этом случае, да и вообще, если не хотите привязываться к интерфейсу, нужно для каждого метода определить обработчик</p><br/>
<div class="spoiler"><b class="spoiler_title">например, так</b><div class="spoiler_text"><pre><code class="cpp">struct plus_handler
{
    template&lt;typename T&gt;
    void operator()(T&amp; t, request::plus::ptr req)
    { // обработка уведомления
        t.target()-&gt;plus( std::move(req), nullptr );
    }

    template&lt;typename T, typename Handler&gt;
    void operator()(T&amp; t, request::plus::ptr req, Handler handler)
    {
        // обработка запроса
        t.target()-&gt;plus( std::move(req), [handler](response::plus::ptr res)
        {
            if ( res != nullptr )
                handler( std::move(res), nullptr );
            else
                handler( nullptr, std::make_unique&lt;wjrpc::service_unavailable&gt;() );
        });
    }
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<div class="spoiler"><b class="spoiler_title">или так</b><div class="spoiler_text"><pre><code class="cpp">struct plus_handler
{
    template&lt;typename T&gt;
    void operator()(T&amp;, request::plus::ptr req)
    {
    }

    template&lt;typename T, typename Handler&gt;
    void operator()(T&amp;, request::plus::ptr req, Handler handler)
    {
        if (req==nullptr)
        {
            handler( nullptr, std::make_unique&lt;wjrpc::invalid_params&gt;() );
            return;
        }
        auto res = std::make_unique&lt;response::plus&gt;();
        res-&gt;value = req-&gt;first + req-&gt;second;
        handler( std::move(res), nullptr );
    }
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Здесь handler обработчик ответа, который первым параметром принимает собственно ответ, а вторым сообщения об ошибке. А t — это ссылка на объект JSON-RPC-обработчика (по аналогии self в python). Включается он в список методов следующим образом:</p><br/>
<pre><code class="cpp">struct method_list: wjrpc::method_list
&lt;
    wjrpc::target&lt;icalc&gt;,
    wjrpc::method&lt; wjrpc::name&lt;_plus_&gt;, wjrpc::invoke&lt;request::plus_json, response::plus_json, plus_handler&gt; &gt;,
    wjrpc::invoke_method&lt;_minus_, request::minus_json, response::minus_json, icalc, &amp;icalc::minus&gt;,
    wjrpc::invoke_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json, icalc, &amp;icalc::multiplies&gt;,
    wjrpc::invoke_method&lt;_divides_, request::divides_json, response::divides_json, icalc, &amp;icalc::divides&gt;
&gt;{};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Как можно догадаться, invoke_method&lt;&gt; это обертка для wjrpc::method&lt;&gt;, которая использует обработчик метода:</p><br/>
<div class="spoiler"><b class="spoiler_title">mem_fun_handler</b><div class="spoiler_text"><pre><code class="cpp">template&lt;
    typename Params,
    typename Result,
    typename I,
    void (I::*mem_ptr)(
        std::unique_ptr&lt;Params&gt;,
        std::function&lt; void(std::unique_ptr&lt;Result&gt;) &gt;
    )
&gt;
struct mem_fun_handler
{
    typedef std::unique_ptr&lt;Params&gt; request_ptr;
    typedef std::unique_ptr&lt;Result&gt; responce_ptr;
    typedef std::unique_ptr&lt; error&gt; json_error_ptr;

    typedef std::function&lt; void(responce_ptr, json_error_ptr) &gt; jsonrpc_callback;

    template&lt;typename T&gt;
    void operator()(T&amp; t, request_ptr req) const;

    template&lt;typename T&gt;
    void operator()(T&amp; t, request_ptr req, jsonrpc_callback cb) const;
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Мы долгое время в своих проектах не использовали асинхронные интерфейсы, да и сама реализация JSON-RPC была несколько проще, но для каждого метода приходилось писать вот такой обработчик, основная задача которого вызвать метод соответствующего класса прикладной логики и отправить ответ.</p><br/>
<p>Но проблема таких обработчиков не в том, что они есть (а ведь можно и без них), а в том, что программисты часто (да почти всегда) начинают переносить туда часть прикладной логики. Абсолютно по разным причинам. Не проработан интерфейс, просто скопипастил откуда-то код, лень подумать и прочее. Зачастую на этапах прототипирования логика не намного сложнее нашего примера. Так зачем плодить сущности, продумывать инициализацию системы и пр? Пару-тройку синглетонов и впендюриваем логику прямо в обработчик. Тем более, не надо думать, как ошибку протаскивать. Потом все это обрастает кодом и потихоньку все забывают, что это прототип, и он уезжает в продакшн. Поддерживать такой код очень тяжело, невозможно покрыть тестами, проще переписать с нуля, чем отрефакторить подобный проект.</p><br/>
<p>В какой-то момент пришла идея “обязать” использовать интерфейсы и стандартизировать их. Благодаря этому появилась возможность сделать обертку типа wjrpc::invoke_method. На этой концепции построен весь фреймворк, а не только JSON-RPC. Концепция заключается в максимальном ограничении возможностей для “творчества” программисту в слоях, которые не связаны с прикладной логикой.</p><br/>
<p>Если вам не нужна асинхронность, то можно также проработать стандарт интерфейса и написать обертку типа wjrpc::invoke_method.</p><br/>
<div class="spoiler"><b class="spoiler_title">Пример синхронного интерфейса</b><div class="spoiler_text"><pre><code class="cpp">struct icalc
{
    virtual ~icalc() {}
    virtual request::plus::ptr plus( request::plus::ptr req) = 0;
    virtual request::minus::ptr minus( request::minus::ptr req) = 0;
    virtual request::multiplies::ptr multiplies( request::multiplies::ptr req) = 0;
    virtual request::divides::ptr divides( request::divides::ptr req) = 0;
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Объект wjrpc::handler&lt;&gt; обычно создается в контексте соединения и имеет такое же время жизни. Если callback, например, нужен объект соединения, чтобы отправить ответ, то нужно поставить защиту на случай, если вызов произойдет после уничтожения объекта.</p><br/>
<div class="spoiler"><b class="spoiler_title">В асинхронной среде так делать нельзя</b><div class="spoiler_text"><pre><code class="cpp">calc-&gt;plus( std::move(req), [this](response::plus::ptr) {} );</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<div class="spoiler"><b class="spoiler_title">И так тоже нельзя</b><div class="spoiler_text"><pre><code class="cpp">std::shared_ptr&lt;calc&gt; pthis = this-&gt;shared_from_this();
calc-&gt;plus( std::move(req), [pthis](response::plus::ptr) {} );</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Второй вариант не подходит, т.к. происходит захват объекта соединения на неопределенное время со всеми ресурсами. Вариант</p><br/>
<pre><code class="cpp">std::weak_ptr&lt;calc&gt; wthis = this-&gt;shared_from_this();
calc-&gt;plus( std::move(req), [wthis](response::plus::ptr)
{
    if ( auto pthis = wthis.lock() )
    {
        /* … */
    }
} );</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>уже лучше, но мы не можем повторно использовать такой объект (например, для пула объектов). Для идентификации объекта можно использовать умный указатель произвольного типа, который нужно просто пересоздать, чтобы отправленные гулять по системе callback-и стали больше не актуальны.</p><br/>
<pre><code class="cpp">std::weak_ptr&lt;int&gt; w = this-&gt;_p; /* _p = std::shared_ptr&lt;int&gt;(1);*/
std::weak_ptr&lt;calc&gt; wthis = this-&gt;shared_from_this();
calc-&gt;plus( std::move(req), [wthis, w](response::plus::ptr)
{
    if ( auto pthis = wthis.lock() )
    {
        if ( nullptr == w.lock() )
            return;
        /* … */
    }
} );</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Для унификации подхода можно разработать вспомогательные классы (нет в wjrpc)</p><br/>
<div class="spoiler"><b class="spoiler_title">callback-обертка</b><div class="spoiler_text"><pre><code class="cpp">template&lt;typename H&gt;
class owner_handler
{
public:
    typedef std::weak_ptr&lt;int&gt; weak_type;
    owner_handler() = default;

    owner_handler(H&amp;&amp; h, weak_type alive)
        : _handler( std::forward&lt;H&gt;(h) )
        , _alive(alive)
    { }

    template &lt;class... Args&gt;
    auto operator()(Args&amp;&amp;... args)
        -&gt; typename std::result_of&lt; H(Args&amp;&amp;...) &gt;::type
    {
        if ( auto p = _alive.lock() )
        {
            return _handler( std::forward&lt;Args&gt;(args)... );
        }
        return typename std::result_of&lt; H(Args&amp;&amp;...) &gt;::type();
    }
private:
    H _handler;
    weak_type _alive;
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<div class="spoiler"><b class="spoiler_title">Владелец (для наследования или агрегации)</b><div class="spoiler_text"><pre><code class="cpp">class owner
{
public:
    typedef std::shared_ptr&lt;int&gt; alive_type;
    typedef std::weak_ptr&lt;int&gt; weak_type;

    owner()
        : _alive( std::make_shared&lt;int&gt;(1) )
    { }

    owner(const owner&amp; ) = delete;
    owner&amp; operator = (const owner&amp; ) = delete;

    owner(owner&amp;&amp; ) = default;
    owner&amp; operator = (owner&amp;&amp; ) = default;

    alive_type&amp; alive() { return _alive; }
    const alive_type&amp; alive() const { return _alive; }
    void reset() { _alive = std::make_shared&lt;int&gt;(*_alive + 1); }

    template&lt;typename Handler&gt;
    owner_handler&lt;typename std::remove_reference&lt;Handler&gt;::type&gt;
    wrap(Handler&amp;&amp; h) const
    {
        return
        owner_handler&lt;
        typename std::remove_reference&lt;Handler&gt;::type
        &gt;(
            std::forward&lt;Handler&gt;(h),
          std::weak_ptr&lt;int&gt;(_alive)
        );
    }
private:
    mutable alive_type _alive;
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<div class="spoiler"><b class="spoiler_title">Пример использования</b><div class="spoiler_text"><pre><code class="cpp">// owner - базовый класс
std::weak_ptr&lt;calc&gt; wthis = this-&gt;shared_from_this();
calc-&gt;plus( std::move(req), this-&gt;wrap([wthis](response::plus::ptr)
{
    if ( auto pthis = wthis.lock() )
    {
        /* … */
    }
}));
// …
// Сброс состояния объекта
owner::reset(); // неотработанные callback-и больше не сработают</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Но это еще не все проблемы с функциями обратного вызова. Они должны быть вызваны обязательно и вызваны ровно один раз. Я не буду сейчас на этом подробно останавливаться, просто имейте это в виду. Напомню, что эта библиотека вырвана из фреймворка, и там эти проблемы так или иначе решены. Связываться или нет с асинхронностью, решать вам.</p><br/>
<h2 id="json-rpc-engine">JSON-RPC Engine</h2><br/>
<p>Движок wjrpc::engine – это, по сути, реестр jsonrpc-обработчиков, который позволяет вынести их в отдельный модуль и управлять временем жизни. Например, входящий поток сообщений можно распределить по очередям с разными приоритетами, исходя из имен методов, и только потом передать в wjrpc::engine. Также он используется для реализации удаленных вызовов к другим сервисам. Для входящих запросов объект соединения захватывается callback-ом, который может гулять неопределенно долго по системе, поэтому он не нужен. Но для исходящих запросов нужен wjrpc::engine, чтобы связать сущность, отправившую запрос с обработчиком, чтобы доставить ответ, когда он придет.</p><br/>
<p>Для демонстрации удаленных вызовов сначала разработаем проксирующий объект, который также реализует интерфейс icalc. Это будет такой злобный прокси, который меняет входные и выходные значения для метода plus, инкрементируя их.</p><br/>
<div class="spoiler"><b class="spoiler_title">calc/calc_p.hpp</b><div class="spoiler_text"><pre><code class="cpp">#pragma once
#include "icalc.hpp"

class calc_p
    : public icalc
{
public:
    void initialize(std::shared_ptr&lt;icalc&gt;);
    virtual void plus( request::plus::ptr req, response::plus::callback cb) override;
    virtual void minus( request::minus::ptr req, response::minus::callback cb) override;
    virtual void multiplies( request::multiplies::ptr req, response::multiplies::callback cb) override;
    virtual void divides( request::divides::ptr req, response::divides::callback cb) override;
private:
    template&lt;typename ReqPtr, typename Callback&gt;
    bool check_( ReqPtr&amp; req, Callback&amp; cb);
    std::shared_ptr&lt;icalc&gt; _next;
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<div class="spoiler"><b class="spoiler_title">calc/calc_p.cpp</b><div class="spoiler_text"><pre><code class="cpp">#include "calc_p.hpp"
#include &lt;memory&gt;

void calc_p::initialize(std::shared_ptr&lt;icalc&gt; next)
{
    _next = next;
}

void calc_p::plus( request::plus::ptr req, response::plus::callback cb)
{
    if ( !this-&gt;check_(req, cb))
        return;
    req-&gt;first++;
    req-&gt;second++;
    _next-&gt;plus(std::move(req), [cb](response::plus::ptr res)
    {
        res-&gt;value++;
        cb(std::move(res) );
    });
}

void calc_p::minus( request::minus::ptr req, response::minus::callback cb)
{
    if ( this-&gt;check_(req, cb))
        _next-&gt;minus(std::move(req), std::move(cb) );
}

void calc_p::multiplies( request::multiplies::ptr req, response::multiplies::callback cb)
{
    if ( this-&gt;check_(req, cb))
        _next-&gt;multiplies(std::move(req), std::move(cb) );
}

void calc_p::divides( request::divides::ptr req, response::divides::callback cb)
{
    if ( this-&gt;check_(req, cb))
        _next-&gt;divides(std::move(req), std::move(cb) );
}

template&lt;typename ReqPtr, typename Callback&gt;
bool calc_p::check_( ReqPtr&amp; req, Callback&amp; cb)
{
    if ( cb==nullptr )
        return false;
    if ( req != nullptr )
        return true;
    cb(nullptr);
    return false;
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Как видно, прокси инициализируется указателем на интерфейс icalc, куда перенаправляет все запросы как есть, кроме метода plus, в котором реализована его “злобность”. Также производится проверка входящих запросов и игнорируются все уведомления и нулевые запросы.</p><br/>
<p>Благодаря асинхронному интерфейсу нашему прокси абсолютно не важно, как будет обработан запрос: синхронно или асинхронно, как придет ответ, тогда он и сделает свои злобные дела. Запрос может быть поставлен в очередь, или может быть выстроена целая цепочка из таких прокси, или этот запрос может быть отправлен на другой сервер.</p><br/>
<p>Для того, чтобы отправить запрос на другой сервер, нам нужно его сериализовать, а для этого опишем JSON-RPC шлюз.</p><br/>
<pre><code class="cpp">JSONRPC_TAG(plus)
JSONRPC_TAG(minus)
JSONRPC_TAG(multiplies)
JSONRPC_TAG(divides)

struct method_list: wjrpc::method_list
&lt;
    wjrpc::call_method&lt;_plus_, request::plus_json, response::plus_json&gt;,
    wjrpc::call_method&lt;_minus_, request::minus_json, response::minus_json&gt;,
    wjrpc::call_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json&gt;,
    wjrpc::call_method&lt;_divides_, request::divides_json, response::divides_json, icalc&gt;
&gt;
{};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Список методов проще, чем для сервисов, ведь нам не нужно описывать обработчик, а только указать JSON-описания запросов и ответов. Но обработчик исходящих вызовов будет посложнее — в нем нужно будет реализовать интерфейс icalc:</p><br/>
<pre><code class="cpp">class handler
: public ::wjrpc::handler&lt;method_list&gt;
, public icalc
{
public:
    virtual void plus( request::plus::ptr req, response::plus::callback cb) override
    {
        this-&gt;template call&lt;_plus_&gt;( std::move(req), cb, nullptr );
    }

    virtual void minus( request::minus::ptr req, response::minus::callback cb) override
    {
        this-&gt;template call&lt;_minus_&gt;( std::move(req), cb, nullptr );
    }

    virtual void multiplies( request::multiplies::ptr req, response::multiplies::callback cb) override
    {
        this-&gt;template call&lt;_multiplies_&gt;( std::move(req), cb, nullptr );
    }

    virtual void divides( request::divides::ptr req, response::divides::callback cb) override
    {
        this-&gt;template call&lt;_divides_&gt;( std::move(req), cb, nullptr );
    }
};</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Реализация каждого метода интерфейса однотипна — нужно вызвать метод call&lt;&gt; с тегом нужного метода, передать туда запрос, обработчик ответа и обработчик ошибки, если необходимо. Обработчик результата осядет в движке до тех пор, пока мы не сообщим ему ответ. Также можно указать время жизни, по истечении которого будет вызван callback с nullptr.</p><br/>
<p>Если в качестве ответа пришла JSON-RPC ошибка, то в callback также будет передан nullptr, что для прикладного кода будет означать, что произошла ошибка, не связанная с прикладной логикой. Пытаться протащить JSON-RPC коды в прикладную часть не очень хорошая идея. Лучше дополнить структуры ответа соответствующими статусами, описывающими ошибки именно прикладной логики.</p><br/>
<p>В качестве примера попробуем связать шлюз, сервис, прокси и собственно калькулятор следующим образом:</p><br/>
<br/>
<p><br/>
Так как наш прокси имеет интерфейс калькулятора, то мы можем с ним работать как с калькулятором, а то, что он делает с запросом, нам не особо важно. Прокси может перенаправить запрос к шлюзу, который также имеет интерфейс калькулятора, поэтому нам не важно, с каким объектом связан прокси. Это может быть еще один прокси, а можно выстроить из них целую цепочку неограниченной длины. Задача шлюза — сериализовать запрос, который мы можем передать по сети. Но в примере мы сразу передадим его на сервис, который его десериализует и, в данном случае, передаст еще одному прокси. </p><br/>
<p>Второй прокси также его модифицирует и уже передает непосредственно калькулятору. Калькулятор его честно отрабатывает и вызывает callback, в котором второй прокси модифицирует ответ и вызывает callback, который пришел от сервиса, который его сериализует. Сериализованный ответ передается JSON-RPC движку, который находит по id вызова соответствующий JSON-RPC обработчик и вызывает его. В нем ответ десериализуется и вызывается callback первого прокси, в котором ответ еще раз модифицируется и передается в наш исходный callback, в котором мы выводим ответ на экран.</p><br/>
<div class="spoiler"><b class="spoiler_title">calc/calc_p.cpp</b><div class="spoiler_text"><pre><code class="cpp">#include "calc/calc1.hpp"
#include "calc/calc_p.hpp"
#include "calc/api/plus_json.hpp"
#include "calc/api/minus_json.hpp"
#include "calc/api/multiplies_json.hpp"
#include "calc/api/divides_json.hpp"

#include &lt;wjrpc/engine.hpp&gt;
#include &lt;wjrpc/handler.hpp&gt;
#include &lt;wjrpc/method.hpp&gt;

#include &lt;iostream&gt;
#include &lt;functional&gt;

namespace service
{
    JSONRPC_TAG(plus)
    JSONRPC_TAG(minus)
    JSONRPC_TAG(multiplies)
    JSONRPC_TAG(divides)

    struct method_list: wjrpc::method_list
    &lt;
    wjrpc::target&lt;icalc&gt;,
    wjrpc::invoke_method&lt;_plus_, request::plus_json, response::plus_json, icalc, &amp;icalc::plus&gt;,
    wjrpc::invoke_method&lt;_minus_, request::minus_json, response::minus_json, icalc, &amp;icalc::minus&gt;,
    wjrpc::invoke_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json, icalc, &amp;icalc::multiplies&gt;,
    wjrpc::invoke_method&lt;_divides_, request::divides_json, response::divides_json, icalc, &amp;icalc::divides&gt;
    &gt;{};

    class handler: public ::wjrpc::handler&lt;method_list&gt; {};

    typedef wjrpc::engine&lt;handler&gt; engine_type;
}

namespace gateway
{
    JSONRPC_TAG(plus)
    JSONRPC_TAG(minus)
    JSONRPC_TAG(multiplies)
    JSONRPC_TAG(divides)

    struct method_list: wjrpc::method_list
    &lt;
    wjrpc::call_method&lt;_plus_, request::plus_json, response::plus_json&gt;,
    wjrpc::call_method&lt;_minus_, request::minus_json, response::minus_json&gt;,
    wjrpc::call_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json&gt;,
    wjrpc::call_method&lt;_divides_, request::divides_json, response::divides_json&gt;
    &gt;
    {};

    class handler
    : public ::wjrpc::handler&lt;method_list&gt;
    , public icalc
    {
    public:
        virtual void plus( request::plus::ptr req, response::plus::callback cb) override
        {
            this-&gt;template call&lt;_plus_&gt;( std::move(req), cb, nullptr );
        }

        virtual void minus( request::minus::ptr req, response::minus::callback cb) override
        {
            this-&gt;template call&lt;_minus_&gt;( std::move(req), cb, nullptr );
        }

        virtual void multiplies( request::multiplies::ptr req, response::multiplies::callback cb) override
        {
            this-&gt;template call&lt;_multiplies_&gt;( std::move(req), cb, nullptr );
        }

        virtual void divides( request::divides::ptr req, response::divides::callback cb) override
        {
            this-&gt;template call&lt;_divides_&gt;( std::move(req), cb, nullptr );
        }
    };

    typedef wjrpc::engine&lt;handler&gt; engine_type;
}

int main()
{
    // Прокси N1
    auto prx1 = std::make_shared&lt;calc_p&gt;();
    // Шлюз
    auto gtw = std::make_shared&lt;gateway::engine_type&gt;();
    // Сервис
    auto srv = std::make_shared&lt;service::engine_type&gt;();
    // Прокси N2
    auto prx2 = std::make_shared&lt;calc_p&gt;();
    // Калькулятор
    auto clc = std::make_shared&lt;calc1&gt;();
    // Связываем второй прокси с калькулятором
    prx2-&gt;initialize(clc);
    // Связываем сервис со вторым прокси и запускаем сервис
    service::engine_type::options_type srv_opt;
    srv_opt.target = prx2;
    srv-&gt;start(srv_opt, 11);

    // Запускаем шлюз
    gateway::engine_type::options_type cli_opt;
    gtw-&gt;start(cli_opt, 22);

    // Регистрируем обработчик шлюза и связываем его с серивисом
    gtw-&gt;reg_io(33, [srv]( wjrpc::data_ptr d, wjrpc::io_id_t /*io_id*/, wjrpc::output_handler_t handler)
    {
        std::cout &lt;&lt; " REQUEST: " &lt;&lt; std::string( d-&gt;begin(), d-&gt;end() ) &lt;&lt; std::endl;
        srv-&gt;perform_io(std::move(d), 44, [handler](wjrpc::data_ptr d)
        {
            // Переопределение обработчика для вывода JSON-RPC ответа
            std::cout &lt;&lt; " RESPONSE: " &lt;&lt; std::string( d-&gt;begin(), d-&gt;end() ) &lt;&lt; std::endl;
            handler(std::move(d) );
        });
    });
    // Находим зарегистрированный обработчик шлюза по его ID
    auto gtwh = gtw-&gt;find(33);
    // Связываем обработчик шлюза с первым прокси
    prx1-&gt;initialize(gtwh);
    // Вызываем plus через прокси (prx1-&gt;gtw-&gt;srv-&gt;prx2-&gt;clc)
    auto plus = std::make_unique&lt;request::plus&gt;();
    plus-&gt;first = 1;
    plus-&gt;second = 2;
    prx1-&gt;plus( std::move(plus), [](response::plus::ptr res)
    {
        std::cout &lt;&lt; "1+2=" &lt;&lt; res-&gt;value &lt;&lt; std::endl;;
    });

    // Вызываем plus через шлюз (gtw-&gt;srv-&gt;prx2-&gt;clc)
    auto minus = std::make_unique&lt;request::minus&gt;();
    minus-&gt;first = 4;
    minus-&gt;second = 3;
    gtwh-&gt;minus( std::move(minus), [](response::minus::ptr res)
    {
        std::cout &lt;&lt; "4-3=" &lt;&lt; res-&gt;value &lt;&lt; std::endl;;
    });
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Результат:</p><br/>
<pre><code class="cpp">REQUEST: {"jsonrpc":"2.0","method":"plus","params":{"first":2,"second":3},"id":1}
RESPONSE: {"jsonrpc":"2.0","result":{"value":8},"id":1}
1+2=9
REQUEST: {"jsonrpc":"2.0","method":"minus","params":{"first":4,"second":3},"id":2}
RESPONSE: {"jsonrpc":"2.0","result":{"value":1},"id":2}
4-3=1</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Первый прокси инкрементировал параметры запроса первый раз, поэтому получаем в JSON-RPC значения 2 и 3 вместо 1 и 2. Второй прокси их также инкрементирует, а потом инкрементирует результат, поэтому сервис отправляет значение 8. Первый прокси еще раз инкрементирует результат, поэтому финальное значение 9. Второй запрос отправляем напрямую в шлюз, минуя первый прокси, но он проходит через второй, а модификация для munus там не предусмотрена, поэтому в результате правильный ответ.</p><br/>
<p>Все двузначные числа в этом примере — это уникальные идентификаторы сущностей, которые должны быть уникальны и, разумеется, их нужно генерировать, а не прописывать в коде напрямую, например, так:</p><br/>
<div class="spoiler"><b class="spoiler_title">create_id</b><div class="spoiler_text"><pre><code class="cpp">inline wjrpc::io_id_t create_id()
{
  static std::atomic&lt;wjrpc::io_id_t&gt; counter( (wjrpc::io_id_t(1)) );
  return counter.fetch_add(1);
}</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div><br/>
<p>Эти идентификаторы служат для связывания сущностей без прямых ссылок на них. Например, в этой строке:</p><br/>
<pre><code class="cpp">  gtw-&gt;reg_io(33, []( wjrpc::data_ptr, wjrpc::io_id_t, wjrpc::output_handler_t)</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Мы в JSON-RPC движке шлюза регистрируем обработчик, который должен отправить данные на сервер. Он должен работать с каким-то объектом, клиентом, для некоего сервера, через который мы можем отправить уже сериализованный запрос. Можно сделать несколько параллельных подключений к серверу и зарегистрировать их. Но вместо этого сериализованный запрос передается напрямую на сервис. А число 44 — это идентификатор некоего объекта сервера, который был создан при подключении клиента. Такие коннекты можно также регистрировать в service::engine_type, но если у нас нет встречных вызовов (когда сервер вызывает метод клиента, а такое в wjrpc тоже можно реализовать), то этого делать не обязательно.</p><br/>
<p>Далее я хотел привести аналогичный пример с взаимодействием между процессами через пайпы(::pipe), с подробным описанием, но думаю, что я вас еще только больше запутаю, да и особо практического смысла это не имеет, а сделать более-менее реалистичный пример взаимодействия двух серверов, со всеми нюансами и чтобы они работали достаточно эффективно, потребует достаточно серьезной кодовой обвязки, к теме статьи отношения не имеющей. Пример построения цепочки процессов с взаимодействием через пайпы есть в разделе examples проекта, также, как и код остальных примеров, приведенных в этой статье.</p><br/>
<p>Но если вы нашли удовлетворительной для себя концепцию сериализации wjson, про которую я писал в предыдущей статье, то в связке wjrpc::incoming_holder вполне можно сделать эффективный JSON-RPC сервер. Если не вызывает отторжения концепция асинхронных интерфейсов, то с помощью wjrpc::handler вы можете сделать все то же самое, но с меньшим количеством run-time кода.</p><br/>
<p>Скачать <a href="https://github.com/mambaru/wjrpc">wjrpc</a> можно здесь. Вам также понадобятся <a href="https://github.com/migashko/faslib">faslib</a> и <a href="https://github.com/mambaru/wjson">wjson</a>. Чтобы скомпилировать примеры и тесты:</p><br/>
<pre><code class="cpp">git clone https://github.com/migashko/faslib.git
git clone https://github.com/mambaru/wjson.git
git clone https://github.com/mambaru/wjrpc.git

# нужно только для компиляции тестов wjrpc
cd faslib
mkdir build
cd build
cmake ..

# собираем примеры и тесты
cd ../../wjrpc
mkdir build
cd build
cmake -DWJRPC_BUILD_ALL=ON ..
make</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre></div></div></div><!----><!----></div><!----><!----></div><!--]--><!----><div class="tm-article-presenter__meta" data-test-id="article-meta-links"><div class="tm-separated-list tag-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[cpp]" class="link"><span>cpp</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[json]" class="link"><span>json</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[json-rpc]" class="link"><span>json-rpc</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[faslib]" class="link"><span>faslib</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[wjson]" class="link"><span>wjson</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[wjrpc]" class="link"><span>wjrpc</span></a><!--]--></li><!--]--><!----></ul></div><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/cpp/" class="link"><!--[--><span>C++</span><!--]--></a><!--]--></li><!--]--><!----></ul></div></div><!----><!--]--></article><!--]--></div><!----></div><div style="" class="tm-article-sticky-panel" data-test-id="article-sticky-panel"><div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons"><div class="article-rating tm-data-icons__item" data-v-b9b05a90><div class="tm-votes-meter votes-switcher" data-v-b9b05a90><svg class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article" height="24" width="24"><title>Всего голосов 23: ↑23 и ↓0</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-rating"></use></svg><span class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating tm-votes-meter__value" data-test-id="votes-meter-value" title="Всего голосов 23: ↑23 и ↓0">+21</span></div><!--teleport start--><!--teleport end--><!----></div><!----><!----><button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button" data-v-861e2740><span class="tm-svg-icon__wrapper icon" data-v-861e2740><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Добавить в закладки</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-favorite"></use></svg></span><span class="counter" title="Количество пользователей, добавивших публикацию в закладки" data-v-861e2740>65</span></button><div class="sharing tm-data-icons__item" title="Поделиться" data-v-daf6ee1d><button class="sharing-button" type="button" data-v-daf6ee1d><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="icon" data-v-daf6ee1d><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button><!--teleport start--><!--teleport end--></div><div class="article-comments-counter-link-wrapper tm-data-icons__item" title="Читать комментарии" data-v-8d952463><a href="/ru/articles/312994/comments/" class="article-comments-counter-link" data-test-id="counter-comments" data-v-8d952463><!--[--><svg class="tm-svg-img icon" height="24" width="24" data-v-8d952463><title>Комментарии</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-comments"></use></svg><span class="value" data-v-8d952463>4</span><!--]--></a><!----></div><!--[--><!--[--><!--[--><!----><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!----></div></div></div><!--[--><!--]--><div class="tm-article-presenter__footer"><!--[--><!--[--><div class="tm-article-blocks"><!----><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><!----><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><!--[--><div class="article-author" data-test-id="article-author-info" data-async-called="true" data-v-af0d0f90><!--[--><!--]--><div class="tm-user-card tm-user-card tm-user-card_variant-article user-card" data-async-called="true" data-v-af0d0f90><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/laphroaig/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><!--[--><div class="tm-entity-image"></div><!--]--></a><div class="tm-user-card__meta"><div class="tm-counter-container karma" title=" 44 голоса " data-v-544d285f><div class="tm-counter-container__header"><!--[--><div class="karma-display positive" data-v-544d285f data-v-3881f4ba>24</div><!----><!--]--></div><div class="tm-counter-container__footer"><!--[--><div class="karma-text" data-v-544d285f>Карма</div><!--teleport start--><!--teleport end--><!--]--></div></div><div class="tm-counter-container"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!----><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score" data-test-id="lever-score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">0</span></span><!--]--></div><!----></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Общий рейтинг</span><!--]--></div></div></div></div></div><div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info"><div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title"><span class="tm-user-card__name tm-user-card__name_variant-article tm-user-card__name">Laphroaig Vi</span><a href="/ru/users/laphroaig/" class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article"><!--[-->@laphroaig<!--]--></a><!----></div><p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">Пользователь</p></div></div><!----><div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons"><!----><div class="tm-user-card__button"><div class="tm-button-follow tm-user-card__button-follow"><!----><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div></div><!----><!--[--><div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations"><svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16"><title>Отправить сообщение</title><use xlink:href="/img/megazord-v28.cba4c116..svg#mail"></use></svg></div><!--]--><!----><!----></div><!----></div><div class="author-contacts" data-test-id="author-contacts" data-v-af0d0f90><!----><!----><!----></div></div><!--]--></div><!--]--><!----></section><!----><!--[--><div class="sponsor-block" style="--d75346b8:0;--11dbf66e:100%;" data-v-580b3119><div class="title" data-v-580b3119>Хабр доступен 24/7 благодаря поддержке друзей</div><div class="content-container" data-v-580b3119><div class="content" data-v-580b3119><div class="content-title-container" data-v-580b3119><div class="content-title" data-v-580b3119>Хабр Курсы для всех</div><div class="sponsor-mark" data-v-580b3119>РЕКЛАМА</div></div><div class="content-text" data-v-580b3119> Практикум, Хекслет, SkyPro, авторские курсы — собрали всех и попросили скидки. Осталось выбрать! </div><a class="content-action" href="https://career.habr.com/courses/?erid=2VSb5wDLYUH&amp;utm_source=habr&amp;utm_medium=sponsorship_hub" target="_blank" data-v-580b3119><button class="btn btn_solid btn_small tm-button_color-horizon" tabindex="0" type="button" data-v-580b3119><!--[--><!--[-->Перейти<!--]--><!--]--></button></a></div></div><div class="footer" data-v-580b3119><!----></div><!----></div><!--]--><!--]--><div class="tm-article-blocks__comments"><div id="publication-comments" class="tm-article-page-comments"><div><!--[--><div class="article-comments-counter-link-wrapper tm-article-comments-counter-button" data-v-8d952463><a href="/ru/articles/312994/comments/" class="article-comments-counter-link button-style" data-test-id="counter-comments" data-v-8d952463><!--[--><svg class="tm-svg-img icon icon--contrasted" height="24" width="24" data-v-8d952463><title>Комментарии</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-comments"></use></svg><span class="value value--contrasted" data-v-8d952463> Комментарии 4 </span><!--]--></a><!----></div><!--]--></div></div></div><!--[--><!--[--><!--]--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]--></div><!----></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim"><!--[--><!--[--><div class="tabs" data-test-id="container" data-v-681e7545><div class="" data-test-id="scroll-area" data-v-681e7545><!--[--><span class="tab-item" data-v-681e7545><button class="active slim tab-link" data-v-681e7545>Лучшие за сутки</button></span><span class="tab-item" data-v-681e7545><button class="slim tab-link" data-v-681e7545>Похожие</button></span><!--]--></div><!----></div><div class="similar-and-daily__tab-view"><div class="daily-articles-list"><ul class="article-card-list" data-v-7f7081d6><!--[--><!--]--><div class="tm-bordered-card" data-v-7f7081d6><!----><!--[--><!--]--></div></ul><div class="daily-articles-block__button-container"><button class="btn btn_transparent btn_small tm-button_color-horizon" tabindex="0" type="button"><!--[--><!--[-->Показать лучшие за всё время<!--]--><!--]--></button></div></div><!----></div><!--]--><!--]--></div><!--]--><!----></section><!--[--><div><div class="placeholder-wrapper"><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="tm-placeholder-promo"><div class="tm-placeholder-promo__header"><div class="tm-placeholder__line tm-placeholder__line_promo-title"></div></div><div class="tm-placeholder-promo__body"><div class="tm-placeholder-promo__posts"><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div></div><div class="tm-placeholder-promo__dots"><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div></div></div></div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----></div></div><div class="placeholder-wrapper"><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="tm-placeholder-inset tm-placeholder-courses"><div class="tm-placeholder-inset__header"><div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div></div><div class="tm-placeholder-inset__body"><ul class="tm-placeholder-list"><!--[--><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><!--]--></ul></div><div class="tm-placeholder-inset__footer"><div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div></div></div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----></div><!--]--><!----><!--[--><!--]--><!--]--></div><!----><!--]--><!--]--></div></div><!--]--></div><!--]--></div></div><div class="tm-page__sidebar"><!--[--><div class="sidebar" data-v-0050f56d><div id="sidebar-window-placement" data-v-0050f56d></div><!--[--><!--]--></div><!--]--></div></div><!--]--></div><!----></div></main><!----></div><div class="tm-footer-menu"><div class="tm-page-width"><!--[--><div class="tm-footer-menu__container"><!--[--><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Ваш аккаунт</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/articles/312994/&amp;hl=ru" rel="nofollow" target="_self">Войти</a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/articles/312994/&amp;hl=ru" rel="nofollow" target="_self">Регистрация</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Разделы</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/ru/articles/" class="footer-menu__item-link">Статьи</a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">Новости</a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">Хабы</a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">Компании</a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">Авторы</a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">Песочница</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Информация</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">Устройство сайта</a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">Для авторов</a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">Для компаний</a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">Документы</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement/?hl=ru_RU" target="_blank">Соглашение</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/?hl=ru_RU" target="_blank">Конфиденциальность</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Услуги</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/corporate-blogs/" target="_blank">Корпоративный блог</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/advertising/" target="_blank">Медийная реклама</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/native-special/" target="_blank">Нативные проекты</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/education-programs/" target="_blank">Образовательные программы</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/hello-startup/" target="_blank">Стартапам</a></li><!--]--></ul></div></div><!--]--></div><!--]--></div></div><div class="tm-footer"><div class="tm-page-width"><!--[--><div class="tm-footer__container"><!----><div class="social-icons tm-footer__social" data-v-d6e8cb42><!--[--><a class="tm-svg-icon__wrapper social-icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" data-v-d6e8cb42><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>VK</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use></svg></a><a class="tm-svg-icon__wrapper social-icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" data-v-d6e8cb42><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Telegram</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a class="tm-svg-icon__wrapper social-icon" href="http://www.youtube.com/@Habr_com" rel="nofollow noopener noreferrer" target="_blank" data-v-d6e8cb42><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Youtube</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a class="tm-svg-icon__wrapper social-icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank" data-v-d6e8cb42><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Яндекс Дзен</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use></svg></a><!--]--></div><!--teleport start--><!--teleport end--><button class="tm-footer__link"><!----> Настройка языка</button><a href="/ru/feedback/" class="tm-footer__link">Техническая поддержка</a><div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2026,</span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank"> Habr </a></span></span></div></div><!--]--></div></div><!----><!----><!--]--></div><!----></div></div>
    <div id="overlays"><!--teleport start anchor--><template><!----></template><!--teleport anchor--><!--teleport start anchor--><template><!----></template><!--teleport anchor--><!--teleport start anchor--><template><!----></template><!----><!--teleport anchor--><!--teleport start anchor--><!----><!--teleport anchor--><!--teleport start anchor--><!----><!--teleport anchor--><!--teleport start anchor--><!----><!--teleport anchor--><!--teleport start anchor--><!----><!--teleport anchor--></div>
    
    
    
    
  
  
    
  
    </body>

    </html>

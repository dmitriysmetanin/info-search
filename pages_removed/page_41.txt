<!DOCTYPE html>
<html lang="ru">

  <head>
    <title>Эволюционный дизайн баз данных &#x2F; Хабр</title>

































    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    

    
    
    
    
    
  </head>
  <body>
    
    <div id="mount"><div id="app"><div class="tm-layout__wrapper"><!--[--><!----><div></div><div class="header-banner-wrapper"><div class="element-wrapper above-header" style="--754c4550:100%;--56cb6579:auto;"><!--[--><div class="placeholder-wrapper banner-container__placeholder"><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="adfox-banner-placeholder above-header" data-v-24012b5e><div class="image loads" data-v-24012b5e></div><div class="lines" data-v-24012b5e><div class="line loads" data-v-24012b5e></div><div class="line loads" data-v-24012b5e></div><div class="line loads" data-v-24012b5e></div></div></div><!----><!----><!----></div><!--[--><div id="adfox_175449164307199013_aboveHeader" class="banner-target"></div><!--]--><!--]--></div></div><header class="tm-header tm-header" data-test-id="header"><!----><!----><div class="tm-page-width"><!--[--><div class="tm-header__container"><button aria-expanded="false" aria-label="Toggle menu" class="burger-button tm-header__button tm-header__burger" data-v-56ed7aae><span class="line top" data-v-56ed7aae></span><span class="line middle" data-v-56ed7aae></span><span class="line bottom" data-v-56ed7aae></span></button><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/feed"><svg class="tm-svg-img tm-header__icon" height="16" width="16"><title>Хабр</title><use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a></span><span class="tm-header__divider"></span><!--[--><a class="tm-header__all-flows" href="/ru/articles/">Все потоки</a><!--]--><!----><div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search" height="24" width="24"><title>Поиск</title><use xlink:href="/img/megazord-v28.cba4c116..svg#search"></use></svg></a><!----><!----><div class="tm-header-user-menu__item tm-header-user-menu__write"><a href="/ru/sandbox/start/" class=""><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write" height="24" width="24"><title>Написать публикацию</title><use xlink:href="/img/megazord-v28.cba4c116..svg#write"></use></svg></a><!----></div><!--[--><div class="tm-header-user-menu__item"><button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings"><svg class="tm-svg-img tm-header-user-menu__icon" height="24" width="24"><title>Настройки</title><use xlink:href="/img/megazord-v28.cba4c116..svg#page-settings"></use></svg></button></div><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/articles/312970/&amp;hl=ru" rel="nofollow" class="tm-header-user-menu__item tm-header-user-menu__login" role="button"><!--[-->Войти<!--]--></a><!--]--><template><!----></template><!--teleport start--><!--teleport end--></div></div><!--]--></div></header><div class="tm-layout"><div class="tm-page-progress-bar"></div><!----><div class="tm-page-width"><!--[--><!----><!----><!----><!--]--></div><main class="tm-layout__container"><div class="tm-page" hl="ru" data-async-called="true" style="--a414e232:300px;--10c4682a:0;--19620736:0;"><!----><div class="tm-page-width"><!--[--><!----><div class="tm-page__wrapper"><!----><div class="tm-page__main_has-sidebar tm-page__main"><div class="pull-down"><!----><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24"><title>Обновить</title><use xlink:href="/img/megazord-v28.cba4c116..svg#pull-arrow"></use></svg></div></div><!--[--><div><!--[--><!----><div class="tm-article-presenter" data-async-called="true"><!--[--><!--]--><div class="tm-article-presenter__body" data-test-id="article-body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><!--[--><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><!--[--><div class="tm-article-presenter__header"><!--[--><!--]--><div class="article-snippet tm-article-presenter__snippet" data-v-085cd854><!--[--><!--]--><div class="meta-container" data-v-085cd854><div class="meta" data-v-085cd854><span class="tm-user-info author" data-v-085cd854><a href="/ru/users/freetonik/" class="tm-user-info__userpic" data-test-id="user-info-pic"><!--[--><div class="tm-entity-image"></div><!--]--></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a href="/ru/users/freetonik/" class="tm-user-info__username" data-test-id="user-info-username"><!--[-->freetonik<!--]--></a><!----><!--[--><span class="tm-article-datetime-published" data-v-085cd854><time data-allow-mismatch datetime="2016-10-18T08:14:00.000Z" title="2016-10-18, 08:14">18  окт  2016 в 08:14</time></span><!--]--></span></span></div><div class="controls" data-v-085cd854><!----><!----><!----><!----></div></div><h1 class="tm-title tm-title_h1" lang="ru" data-test-id="articleTitle" data-v-085cd854><span>Эволюционный дизайн баз данных</span></h1><div class="stats" data-test-id="articleStats" data-v-085cd854><!----><div class="tm-article-reading-time" data-v-085cd854><span class="tm-svg-icon__wrapper tm-article-reading-time__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Время на прочтение</title><use xlink:href="/img/megazord-v28.cba4c116..svg#clock"></use></svg></span><span class="tm-article-reading-time__label">32 мин</span></div><span class="tm-icon-counter tm-data-icons__item reach-counter" data-v-085cd854><svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24"><title>Охват и читатели</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-views"></use></svg><span class="tm-icon-counter__value" title="22053">22K</span></span></div><div class="tm-publication-hubs__container" data-test-id="articleHubsList" data-v-085cd854><div class="tm-publication-hubs"><!--[--><span class="tm-publication-hub__link-container"><a href="/ru/hubs/analysis_design/" class="tm-publication-hub__link"><!--[--><span>Анализ и проектирование систем</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб"> * </span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/refactoring/" class="tm-publication-hub__link"><!--[--><span>Проектирование и рефакторинг</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб"> * </span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/industrial_control_system/" class="tm-publication-hub__link"><!--[--><span>Промышленное программирование</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб"> * </span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/cvs/" class="tm-publication-hub__link"><!--[--><span>Системы управления версиями</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб"> * </span><!--]--></a></span><!--]--></div></div><div class="tm-article-labels" data-test-id="articleLabels" data-v-085cd854 data-v-bfa2437b><div class="tm-article-labels__container" data-v-bfa2437b><!----><!--[--><!----><!--[--><div class="tm-publication-label tm-publication-label_variant-translation" data-v-bfa2437b><span>Перевод</span></div><!--]--><!--]--></div></div><!----><!----><!--teleport start--><!--teleport end--></div></div><!--[--><div class="tm-article-presenter__origin"><a class="tm-article-presenter__origin-link" href="http://martinfowler.com/articles/evodb.html" target="_blank">Автор оригинала: <span>Pramod Sadalage, Martin Fowler</span></a></div><div class="article-body" data-gallery-root lang="ru" data-v-aad06d04><div data-v-aad06d04><!--[--><!--]--></div><div id="post-content-body" data-v-aad06d04><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p></p><br/>
<p><em>За последнее десятилетие мы разработали и усовершенствовали несколько методов, которые позволяют дизайну баз данных эволюционировать параллельно с разработкой приложения.</em></p><br/>
<p><em>Это очень ценное свойство гибких методологий. Методы опираются на применение непрерывной интеграции и автоматизированного рефакторинга к разработке баз данных, а также на тесное взаимодействие между разработчиками приложений и администраторами БД. Эти методы работают как в препродакшн и в уже стартовавших системах, в свежих проектах без легаси, так и в унаследованных системах.</em></p><br/>
<p>В последнее десятилетие мы наблюдаем рост <a href="http://www.martinfowler.com/articles/newMethodology.html">гибких методологий</a>. По сравнению со своими предшественниками, они изменяют требования к дизайну баз данных. Одно из важнейших среди требований – идея эволюционной архитектуры. В гибком проекте вы предполагаете, что не можете заранее поправить требования системы. В результате, иметь детализированную, четкую стадию дизайна в начале проекта становится непрактично. Архитектура системы должна эволюционировать одновременно с итерациями софта. Гибкие методы, в частности, экстремальное программирование (XP), имеют набор методик, которые делают эту эволюционную архитектуру практичной.<a name="habracut"></a></p><br/>
<p>Когда мы и наши коллеги из ThoughtWorks стали делать agile-проекты, мы поняли, что нам нужно решать задачу эволюции баз данных, для поддержки эволюции архитектуры. Мы начали примерно в 2000 году с проекта, база данных которого в итоге дошла почти до 600 таблиц. В процессе работы над этим проектом мы разработали методы, которые позволили поменять схему и удобно мигрировать существующие данные. Это сделало базу данных полноценно гибкой и эволюционируемой. Мы описали методы в более ранних версиях этой статьи, и её содержание вдохновило другие команды и toolsets. С тех пор мы использовали и дальше развивали методы в сотнях проектов по всему миру, от небольших групп до крупных многонациональных программ. Мы давно собирались обновить эту статью, и теперь такая возможность появилась.</p><br/>
<hr/><br/>
<h2 id="dzhen-realizuet-novuyu-yuzer-istoriyu">Джен реализует новую юзер-историю</h2><br/>
<p>Для того, чтобы получить представление о том, как все это работает, давайте набросаем в общих чертах что происходит, когда разработчик (Джен) пишет код, чтобы реализовать новую пользовательскую историю. История описывает пользователя, у которого есть возможность видеть, искать и обновлять позицию, номер партии и серийный номер товаров, находящихся в наличии. Глядя на схему базы данных, Джен видит, что в настоящее время нет никаких полей в таблице наличия товара, только одно поле inventory_code, которое является конкатенацией (объединением) этих трёх полей. Она должна разделить единый код на три отдельных поля: location_code, batch_number и serial_number.</p><br/>
<p>Вот шаги, которые она должна совершить:</p><br/>
<ul>
<li>Добавить новые столбцы к таблице inventory в уже существующей схеме.</li>
<li>Написать скрипт миграции и разделить данные из столбца inventory_code по созданным столбцам: location_code, batch_number и serial_number.</li>
<li>Изменить код приложения для использования новых столбцов.</li>
<li>Изменить все части кода базы данных, такие как выборки, хранимые процедуры и триггеры, чтобы они использовали новые столбцы.</li>
<li>Изменить все индексы, базируемые на inventory_code.</li>
<li>Закомитить скрипт миграции базы данных и все изменения кода приложения в систему управления версиями</li>
</ul><br/>
<p>Для добавления новых колонок и переноса данных Джен пишет скрипт миграции на SQL, который она может сравнить с текущей схемой. Это и одновременно изменит схему и перенесёт все имеющиеся данные о товарах в наличии.</p><br/>
<pre><code class="sql">ALTER TABLE inventory ADD location_code VARCHAR2(6) NULL;
ALTER TABLE inventory ADD batch_number VARCHAR2(6) NULL;
ALTER TABLE inventory ADD serial_number VARCHAR2(10) NULL;

UPDATE inventory SET location_code = SUBSTR(product_inventory_code,1,6);
UPDATE inventory SET batch_number = SUBSTR(product_inventory_code,7,6);
UPDATE inventory SET serial_number = SUBSTR(product_inventory_code,11,10);

DROP INDEX uidx_inventory_code;

CREATE UNIQUE INDEX uidx_inventory_identifier
  ON inventory (location_code,batch_number,serial_number);

ALTER TABLE product_inventory DROP COLUMN inventory_code;</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Джен запускает скрипт миграции в локальной копии базы данных на своём компьютере. Затем она переходит к обновлению кода, чтобы использовать новые колонки. В процессе она применяет существующий набор тестов к новому коду, чтобы обнаружить любые изменения в поведении приложения. Некоторые тесты, те, которые покрывали комбинированную колонку, нужно обновить. Возможно, нужно добавить ещё какие-то тесты. После того, как Джен сделала всё это, и приложение прошло все тесты на её компьютере, она грузит изменения в общий проектный репозиторий, который мы называем <strong>mainline</strong>. Эти изменения включают в себя скрипты миграции и изменения кода приложения.</p><br/>
<p>Если Джен не слишком хорошо знакома с внесением этих изменений, ей повезло, что они универсальны для баз данных. Поэтому она может заглянуть в <a href="http://martinfowler.com/books/refactoringDatabases.html">книгу про рефакторинг баз данных</a>. В сети есть <a href="http://databaserefactoring.com/SplitColumns.html">справка</a> по этой теме.</p><br/>
<p>После того, как изменения оказываются в mainline, они подхватываются <a href="http://www.martinfowler.com/articles/continuousIntegration.html">сервером непрерывной интеграции</a>. Он запускает скрипты миграции на копии базы данных в mainline, а затем все тесты приложения. Если всё проходит успешно, этот процесс будет повторятся на каждом этапе <a href="http://martinfowler.com/bliki/DeploymentPipeline.html">Deployment Pipeline</a>, включая тестирование (QA) и staging. Тот же самый код, наконец, запустится в production, на этот раз обновляя реальную схему базы данных и данные.</p><br/>
<p>В небольшой пользовательской истории, как в примере, только одна миграция базы данных, крупные пользовательские истории часто разбиваются на несколько отдельных миграций для каждого изменения в БД. У нас правило — делать каждое изменение БД насколько возможно маленьким. Чем меньше, тем легче получить правильный результат, а любые ошибки быстро обнаружить и отладить. Миграции, как в примере, легко совмещать, так что лучше делать много мелких.</p><br/>
<h2 id="rabota-s-izmeneniyami">Работа с изменениями</h2><br/>
<p>Поскольку гибкие методы стали популярны в начале 2000-х годов, одна из их наиболее очевидных характеристик это склонность к изменениям. Перед тем, как они появились, чаще всего представления о софте были такими: понимание требований на раннем этапе, установление требований, использование требований как основы для дизайна, исполнение дизайна, а затем исполнение проекта. Этот управляемый планом цикл часто называют (обычно с насмешкой) водопадным подходом.</p><br/>
<p>Такие подходы используют в попытках свести к минимуму изменения, что выливается в чрезмерную предварительную работу. А когда предварительная работа закончена, изменения приводят к серьезным проблемам. В результате, если требования меняются, эти подходы ведут к неисправностям, а пересмотр требований — головная боль для таких процессов.</p><br/>
<p>Гибкие процессы имеют другие методические подходы к изменениям. Они дружелюбны к изменениям даже на поздних стадиях разработки проекта. Изменения контролируются, но характер процесса делает их вероятными настолько, насколько возможно. Отчасти — это ответ на встроенную нестабильность требований многих проектов, отчасти — концепция более качественной поддержки динамических бизнес-структур и помощи им с изменениями, в условиях давления конкурентов.</p><br/>
<p>Для того, чтобы поставить этот процесс на колёса, вам нужно изменить отношение к дизайну. Вместо того чтобы думать о дизайне как о фазе, которая заканчивается перед фазой конструирования, вы смотрите на дизайн, как на непрерывный процесс, который чередуется с конструированием, тестированием и даже доставкой. Такой контраст между плановым и эволюционным проектированием.</p><br/>
<p>Один из важнейших вкладов гибких методов — подходы, при которых у эволюционного дизайна есть возможность держать работу под контролем. И вместо привычного хаоса, который часто берёт верх, когда конструирование не запланировано заранее, эти методы рождают способы контроля эволюционного дизайна и делают их практичными.</p><br/>
<p>Важная часть этого подхода — итеративная разработка, когда полный жизненный цикл софта запускается много раз за всё существование проекта. Гибкие процессы запускают полный жизненный цикл в каждой итерации, завершая итерацию рабочим, протестированным, интегрированным кодом и небольшим подмножеством требований конечного продукта. Эти итерации короткие — от нескольких часов до нескольких недель: более опытные команды используют более короткие итерации.</p><br/>
<p>Хотя интерес к этим методам и их использование возросли, один из самых важных вопросов — как использовать эволюционный дизайн для баз данных. Продолжительное время группа людей из сообщества баз данных воспринимала дизайн БД как что-то обязательно требующее предварительного планирования. Изменение схемы базы данных в конечных фазах разработки, как правило, приводит к распространяющимся дефектам приложения. Кроме того, изменение схемы после деплоя приводит к болезненной миграции данных.</p><br/>
<p>В течение последних десяти с половиной лет, мы участвовали во многих крупных проектах, которые использовали эволюционный дизайн БД и он успешно работал. Некоторые проекты включали в себя более 100 человек в нескольких рабочих точках по всему миру. Другие — более полумиллиона строк кода, более 500 таблиц. У некоторых из них в production было несколько версий приложения и каждое требовало круглосуточного обслуживания. В ходе этих проектов нам попадались итерации длительностью в месяц и в неделю, но более короткие итерации работали лучше. Методы, описанные ниже, позволили сделать это возможным.</p><br/>
<p>С первых дней мы пытались распространить методики на большее количество своих проектов. Мы получали больше опыта от покрытия большего количества случаев, и теперь все наши проекты используют этот подход. Мы также черпаем вдохновение, идеи и опыт у других людей, пользующихся этим подходом.</p><br/>
<h2 id="ogranicheniya">Ограничения</h2><br/>
<p>Прежде чем мы начнём разбираться с подходами, хочу сказать, что мы не решили все проблемы эволюционного дизайна баз данных.</p><br/>
<p>У нас были проекты с сотнями розничных магазинов, с их собственными базами данных, каждую из которых нужно было обновлять. Но мы еще не рассматривали ситуацию, когда у большой группы сайтов есть много настроек. Как пример, можно рассмотреть приложение для малого бизнеса, которое позволяет делать настройки схемы, задеплоенной в тысячах различных небольших компаниях.</p><br/>
<p>Все чаще мы видим, как люди используют множество схем как часть единой среды БД. Мы работали с проектами, использовавшими по нескольку подобных схем, но десятки или сотни — не пробовали. Мы прогнозируем в течение следующих нескольких лет разобраться с этой ситуацией.</p><br/>
<p>Мы не считаем, что эти проблемы неразрешимы. В конце концов, когда мы написали оригинальную версию этой статьи, мы не избавились от проблемы беспрерывной работы или интеграции БД. Мы нашли способы как с ними справляться и надеемся, что расширим границы эволюционного дизайна БД. Но пока этого не произошло, мы не будем утверждать, что не способны решить подобные задачи.</p><br/>
<h2 id="metodiki">Методики</h2><br/>
<p>Наш подход к эволюционному дизайну БД построен на нескольких важных методиках.</p><br/>
<h3 id="administratory-bd-tesno-vzaimodeystvuyut-s-razrabotchikami">Администраторы БД тесно взаимодействуют с разработчиками</h3><br/>
<p>Один из принципов гибких методов — работники с разными навыками и опытом должны очень тесно взаимодействовать друг с другом. Они не должны общаться только через официальные встречи и документы. Им нужно контактировать и работать друг с другом всё время. Это влияет на всех: аналитиков, руководителей проекта, экспертов в предметной области, разработчиков… и администраторов БД.</p><br/>
<p>В каждой задаче, над которой трудится разработчик, потенциально нужна помощь администратора БД. И разработчики, и администраторы должны предусматривать, будут ли входить значительные изменения схемы базы данных в задачу разработки. Если да, то разработчик должен проконсультироваться с администратором БД, чтобы решить, как вносить изменения. Разработчик знает, какая новая функциональность требуется, а у администратора есть единое представление данных текущего приложения и других окружающих приложений. Часто разработчики имеют представление о приложении, над которым работают, но не имеют обо всех остальных upstream или downstream зависимостях схемы. Даже если это единое приложение БД, в нём могут содержаться зависимости, о которых разработчик не в курсе.</p><br/>
<p>В любой момент разработчик может обратиться к администратору и попросить разобраться в изменениях базы данных. Когда используется парный стиль, разработчик узнает о том, как работает база данных, а администратор изучает особенности требований к базе данных. Чаще всего вопрос — обращаться по поводу изменений к АБД или нет — лежит на разработчике, если его беспокоит влияние изменений на базу данных. Но АБД тоже принимают инициативу. Когда они видят требования, которые, по их мнению, могут оказать значительное влияние на данные, они могут обращаться к разработчикам, чтобы обсудить воздействие на БД. АБД может также затронуть миграции, поскольку они зафиксированы в системе управления версиями. Так как обратная миграция всех раздражает, мы выигрываем от каждой маленькой миграции, которую проще реверсировать.</p><br/>
<p>Чтобы сделать это возможным, АБД должен охотно идти навстречу и быть в доступности. Нужно, чтобы разработчик мог легко нагрянуть и задать несколько вопросов в слаке или хипчате — любом средстве связи, которое используют разработчики. Когда вы организуете рабочее пространство для проекта, постарайтесь чтобы АБД и разработчики сидели ближе друг к другу, чтобы им было легко контактировать. Убедитесь в том, что администраторы в курсе любых встреч, связанных с дизайном приложения, чтобы они могли легко подтянуться. В рабочих микроклиматах нам часто встречаются люди, создающие барьеры между администраторами БД и функциями разработки. Чтобы эволюционный процесс дизайна БД работал, нужно стереть эти барьеры.</p><br/>
<h3 id="vse-artefakty-bazy-dannyh-are-version-controlled-with-application-code">Все артефакты базы данных are version controlled with application code</h3><br/>
<p>Разработчики значительно выигрывают от использования контроля версий всех своих артефактов: кода приложения, функциональных и модульных тестов, кода, вроде скриптов сборки, Chef или Puppet скриптов, используемых для создания рабочего окружения.</p><br/>
<p><br/>
<em>Рис 1: Все артефакты базы данных в системе управления версиями, вместе с другими артефактами проекта</em></p><br/>
<p>Точно так же все артефакты базы данных должны быть в системе управления версиями, в том же репозитории, который используется всеми остальными. Преимущества у этого:</p><br/>
<ul>
<li>Всё находится в одном месте и любому участнику проекта легко найти нужное.</li>
<li>Каждое изменение базы данных сохраняется, что позволяет легко сделать проверку при возникновении любой проблемы. Мы можем отследить любой деплой базы данных и найти требуемое состояние схемы и вспомогательных данных.</li>
<li>Мы не делаем деплои, если база данных не синхронизируется с приложением, что приводит к возврату ошибок и обновлению данных.</li>
<li>Мы можем легко создавать новые среды: для разработки, тестирования, и конечно production. Все, что нужно для создания работающей версии приложения, должно находиться в одном репозитории, чтобы можно было быстро склонировать и собрать.</li>
</ul><br/>
<h3 id="vse-izmeneniya-bazy-dannyh---eto-migracii">Все изменения базы данных — это миграции</h3><br/>
<p>Во многих организациях существует процесс, в котором разработчики вносят изменения в базу данных с помощью инструментов редактирования схемы и ad-hoc SQL для данных. После того, как они заканчивают разработку, администраторы БД сравнивают разрабатываемую базу данных с базой данных в production и вносят туда соответствующие изменения, переводя приложение в рабочее состояние. Но в production это делать сложно, потому что контекстный индикатор изменений, тот что был в разработке, потерялся. Нужно снова разбираться, зачем были сделаны изменения, но уже другой группе людей.</p><br/>
<p>Чтобы этого избежать, мы предпочитаем фиксировать изменения во время разработки и сохранять их как артефакт первого уровня, который можно потом протестировать и задеплоить с тем же процессом и контролем, как для изменений в коде приложения. Мы делаем это, отображая каждое изменение в базе данных, как скрипт миграции базы данных, которые как и изменения в коде приложения, находятся в системе контроля версий. Эти скрипты миграции включают в себя: изменения схемы, изменения кода базы данных, обновления ссылочных данных, обновления данных о транзакциях и исправление проблем с данными из-за багов в production.</p><br/>
<p>Вот изменение, добавка min_insurance_value и max_insurance_value к таблице equipment_type, с несколькими дефолтными значениями.</p><br/>
<pre><code class="sql">ALTER TABLE equipment_type ADD(
  min_insurance_value NUMBER(10,2),
  max_insurance_value NUMBER(10,2)
);

UPDATE equipment_type SET
          min_insurance_value  =  3000,
          max_insurance_value = 10000000;          </code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Это изменение добавляет набор постоянных данных к таблицам location и equipment_type.</p><br/>
<pre><code class="sql">-- Create new warehouse locations #Request 497
INSERT INTO location (location_code, name , location_address_id,
  created_by, created_dt)
VALUES ('PA-PIT-01', 'Pittsburgh Warehouse', 4567,
  'APP_ADMIN' , SYSDATE);
INSERT INTO location (location_code, name , location_address_id,
  created_by, created_dt)
VALUES ('LA-MSY-01', 'New Orleans Warehouse', 7134,
  'APP_ADMIN' , SYSDATE);

-- Create new equipment_type #Request 562
INSERT INTO equipment_type (equipment_type_id, name,
  min_insurance_value, max_insurance_value, created_by, created_dt)
VALUES (seq_equipment_type.nextval, 'Lift Truck',
  40000, 4000000, 'APP_ADMIN', SYSDATE);</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>При работе с помощью такого метода, нам никогда не приходится использовать инструменты редактирования схем, типа Navicat, DBArtisanor или SQL Developer, и мы никогда не запускаем беспроводные DDL или DML, чтобы добавить постоянные данные или исправить ошибки. Кроме обновлений в базе данных, которые происходят из-за приложений, все изменения делаются миграциями.</p><br/>
<p>Называя миграции наборами команд SQL, мы рассказываем только часть истории, но для того, чтобы правильно их применять, нам нужно что-то ещё.</p><br/>
<ul>
<li>Каждая миграция требует уникальной идентификации.</li>
<li>Нужно отслеживать, какие миграции были применены к базе данных</li>
<li>Нужно управлять ограничениями последовательности действий между миграциями. В приведенном выше примере мы должны применить в начале миграцию ALTER TABLE, иначе вторая миграция не сможет добавить вставку equipment type.</li>
</ul><br/>
<p>Мы обрабатываем эти требования, присваивая каждой миграции порядковый номер. Он действует как уникальный идентификатор и гарантирует, что можно поддерживать порядок, в котором они применяются в базе данных. Когда разработчик создает миграцию, он помещает SQL в текстовый файл внутри папки миграции, в пределах репозитория управления версиями проекта. Он смотрит на самый высокий используемый в данный момент номер в папке миграции, и использует это число вместе с описанием, чтобы дать имя файлу. Самая ранняя пара миграций может быть названа 0007_add_insurance_value_to_equipment_type.sql и 0008_data_location_equipment_type. </p><br/>
<p>Для того, чтобы отслеживать применение миграций в базе данных, мы используем changelog таблицу. Фреймворки миграции БД, как правило, создают эту таблицу и автоматически обновляют её каждый раз, когда применяется миграция. Тогда база данных всегда может сообщить с какой миграцией была синхронизация. Если мы не используем такой фреймворк, потому что таких не существует, в начале работы мы автоматизируем процесс с помощью скрипта. </p><br/>
<p><br/>
<em>Рис 2: Таблица changelog, поддерживаемая фреймфорком миграции базы данных</em></p><br/>
<p>С помощью этой схемы нумерации, мы можем отследить изменения, когда они применяются к тому множеству баз данных, с которым мы работаем.</p><br/>
<p><br/>
<em>Рисунок 3: Цикл скрипта миграции с момента его создания до деплоя в production</em></p><br/>
<p>Некоторые из этих миграциий, вероятно, понадобится реализовать чаще, чем миграции, связанные с новыми компонентами. В этом сценарии мы заметили, что полезно иметь отдельный репозиторий миграции или папку для отладки багов, относящихся к данным.</p><br/>
<p><br/>
<em>Рис 4: Отдельные папки для управления новыми изменениями компонентов базы данных и исправлений данных в production</em></p><br/>
<p>Каждую из этих папок можно отслеживать отдельно с помощью инструментов для миграции базы данных: Flyway, dbdeploy, MyBatis или аналогичных. У каждой должна быть отдельная таблица для хранения количества миграций. Свойство flyway.table в Flyway используется для изменения названия таблицы, где хранятся метаданные миграции.</p><br/>
<h3 id="kazhdyy-imeet-svoy-ekzemplyar-bazy-dannyh">Каждый имеет свой экземпляр базы данных</h3><br/>
<p>В большинстве компаний-разработчиков используется единая база данных, совместно, всеми работниками. Возможно, они используют отдельную базу данных для тестировщиков или staging, но принципиально ограничивают количество активных баз данных. Совместное использование БД подобным образом — это следствие того, что копии сложно устанавливать и управлять ими. В итоге компании минимизируют их количество. Контроль за тем, на ком ответственность менять схему в таких ситуациях разный: некоторые компании требуют, чтобы все изменения делались командами администраторов, другие позволяют разработчикам делать любые изменения, а администраторов привлекают, когда изменения переходят на следующий уровень.</p><br/>
<p>Когда мы начали экспериментировать с гибкими проектами, мы заметили, что разработчики обычно работают по одной схеме — используют собственную копию кода. Так же как люди учатся, перебирая разные варианты, разработчики экспериментируют с реализацией компонентов и могут сделать несколько попыток, перед тем как выберут нужную. Нужно, чтобы у них была возможность экспериментировать в своём рабочем пространстве, а потом загружать код в общее хранилище, когда всё более стабильно. Если все работают в одном пространстве, то неизбежно мешают друг другу полуготовыми изменениями. Хоть мы и предпочитаем непрерывную интеграцию, когда интеграции происходят не чаще чем через несколько часов, личная рабочая копия играет важную роль. Системы контроля версий поддерживают эту работу, позволяя разработчикам работать независимо и поддерживают интеграцию их работы в mainline копию.</p><br/>
<p>Такое разделение работает с файлами, но также может работать с базами данных. У каждого разработчика – свой экземпляр базы данных, который он может свободно изменять, не затрагивая работу других. Когда их работа будет готова, они могут загрузить и расшарить изменения, и мы это увидим в следующем разделе.</p><br/>
<p>Эти отдельные базы данных могут быть либо отдельными схемами на общем сервере или, что сегодня встречается чаще, отдельными базами данных, запущенными на ноутбуке или в терминале разработчика. Десять лет назад лицензирование отдельных баз данных обходилось слишком дорого, сегодня же такое встречается редко, в том числе потому что стали популярны базы данных с открытым исходным кодом. Нам показалось удобным запускать базу данных на виртуальной машине разработчика. Мы установили билд базы данных на виртуальной машине, используя <a href="https://www.vagrantup.com/">Vagrant</a> и подход <a href="http://martinfowler.com/bliki/InfrastructureAsCode.html">"инфраструктура как код"</a>, чтобы разработчик не разбирался в деталях установки БД и не делал это вручную.</p><br/>
<p><br/>
<em>Рис 5: Проблема использования единой схемы базы данных для всей команды разработчиков</em></p><br/>
<p><br/>
<em>Рис 6: Каждый член команды получает свою схему базы данных для разработки и тестирования</em></p><br/>
<p>Многие администраторы до сих пор воспринимают несколько баз данных как зло, которое нужно избегать из-за сложностей, но мы считаем, что можно легко управлять примерно сотнями экземпляров базы данных. Главное, чтобы инструменты позволяли вам управлять базами данных в том же объёме, что и файлами.</p><br/>
<pre><code class="sql">&lt;target name="create_schema"
        description="create a schema as defined in the user properties"&gt;
    &lt;echo message="Admin UserName: ${admin.username}"/&gt;
    &lt;echo message="Creating Schema: ${db.username}"/&gt;
    &lt;sql password="${admin.password}" userid="${admin.username}"
         url="${db.url}" driver="${db.driver}" classpath="${jdbc.classpath}"
         &gt;
        CREATE USER ${db.username} IDENTIFIED BY ${db.password} DEFAULT TABLESPACE ${db.tablespace};
        GRANT CONNECT,RESOURCE, UNLIMITED TABLESPACE TO ${db.username};
        GRANT CREATE VIEW TO ${db.username};
        ALTER USER ${db.username} DEFAULT ROLE ALL;
    &lt;/sql&gt;
&lt;/target&gt;</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Создание схем разработки можно автоматизировать, используя скрипт сборки, чтобы уменьшить нагрузку на администраторов. Эту автоматизацию также можно ограничить только средой разработки.</p><br/>
<pre><code class="sql">&lt;target name="drop_schema"&gt;
    &lt;echo message="Admin UserName: ${admin.username}"/&gt;
    &lt;echo message="Working UserName: ${db.username}"/&gt;
    &lt;sql password="${admin.password}" userid="${admin.username}"
         url="${db.url}" driver="${db.driver}" classpath="${jdbc.classpath}"
         &gt;
        DROP USER ${db.username} CASCADE;
    &lt;/sql&gt;
&lt;/target&gt;</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Например, разработчик присоединяется к проекту, проверяет код и начинает устанавливать свою среду разработки. Он использует файл-шаблон build.properties и вносит изменения, например устанавливая Jen в качестве db.username, и так далее для остальных настроек. После того, как настройки сделаны, он может просто запустить create_schema и у него будет своя схема на общем сервере БД или на сервере БД его ноутбука.</p><br/>
<p>С помощью созданной схемы, он может запустить скрипт миграции базы данных, чтобы собрать весь контент БД и наполнить свой экземпляр БД таблицами, индексами, представлениями, последовательностями, хранимыми процедурами, триггерами, синонимами и другими специфическими объектами базы данных.</p><br/>
<p>Подобные скрипты существуют и для удаления схем, если они больше не нужны, или просто потому, что разработчик хочет всё почистить и начать заново с новой схемы. Среды баз данных должны быть <a href="http://martinfowler.com/bliki/PhoenixServer.html">фениксами</a> — регулярно сгорать и перестраиваться при желании. При таком подходе меньше рисков для накопления характеристик среды, не приспособленных к повторению или проверке.</p><br/>
<p>Потребность в приватном рабочем пространстве удобна разработчикам, но она удобна и всему остальному коллективу. QA должны создавать свои собственные базы данных, чтобы можно было работать без рисков запутаться в изменениях, о которых они не знают. У администраторов должна быть возможность экспериментировать со своей копией базы данных, потому что они экспериментируют с вариантами моделирования или повышения производительности.</p><br/>
<h3 id="razrabotchiki-postoyanno-integriruyut-izmeneniya-bazy-dannyh">Разработчики постоянно интегрируют изменения базы данных</h3><br/>
<p>Несмотря на то, что разработчики часто экспериментируют в песочнице, важный момент — так же часто интегрировать изменения, которые они совершают через непрерывную интеграцию (CI). CI включает настройку сервера интеграции, который автоматически собирает и тестирует mainline приложения. У нас есть железное правило: каждый разработчик делает интеграцию в mainline, хотя бы один раз в день. Среди инструментов, помогающих с интеграцией — GoCD, SNAP CI, Jenkins, Bambooand Travis CI.</p><br/>
<p><br/>
<em>Рис 7: База данных изменяется, создаются миграции и интегрируются аналогично коду приложения</em></p><br/>
<p>На 7 изображении показан флоу того, как происходит разработка миграций базы данных, локальное тестирование, проверка в системе управления версиями, подхватывание сервером CI и применение к интеграционной базе данных, повторное тестирование и упаковка для использования.</p><br/>
<p>Давайте посмотрим на пример</p><br/>
<p>1) Джен приступает к разработке, которая включает изменение схемы базы данных. Если изменение простое, например, добавление колонки, Джен думает, как внести изменения напрямую. Если сложное, она находит администратора БД и обсуждает вопрос с ним.</p><br/>
<p>После того, как она выясняет что делать с изменением, она пишет миграцию.</p><br/>
<pre><code class="sql">ALTER TABLE project ADD projecttypeid NUMBER(10) NULL;

ALTER TABLE project ADD (CONSTRAINT fk_project_projecttype
  FOREIGN KEY (projecttypeid)
  REFERENCES projecttype DEFERRABLE INITIALLY DEFERRED);

UPDATE project
      SET projecttypeid = (SELECT projecttypeid
                  FROM projecttype
                  WHERE name='Integration');</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Добавление обнуляемого столбца — это обратно совместимое изменение, поэтому она может интегрировать изменение, не изменяя код приложения. Но если это не обратно совместимое изменение, вроде разделения таблицы, то Джен понадобится изменить код приложения.</p><br/>
<p>2) После того, как Джен закончит изменения, она готова к интеграции. Первый шаг — обновление локальной копии Джен из mainline. Это те изменения, которые сделали другие члены команды, пока она работала над своей задачей. Затем она проверяет свои изменения, работает с обновлениями, пересобирая базу данных и прогоняя все тесты.</p><br/>
<p>Если она сталкивается с проблемами из-за изменений, сделанных другими разработчиками — изменений, которые конфликтуют с её изменениями — она должна исправить эти проблемы в своей копии. Как правило, такие конфликты легко поправить, но иногда они оказываются запутанными. Часто такие усложнённые конфликты ведут к необходимости обсуждения между Джен и её коллективом, чтобы разобраться в накладках.</p><br/>
<p>После того, как её локальная копия снова в рабочем состоянии, она проверяет, появились ли дополнительные изменения пока она делала исправления. Если были, Джен нужно повторить интеграцию с новыми изменениями. Обычно происходит не больше одного или двух подобных циклов, перед тем, как её код полностью интегрируется в mainline.</p><br/>
<p>3) Джен пушит изменения в mainline. Поскольку изменение обратно совместимо с существующим кодом приложения, она может интегрировать изменения базы данных перед обновлением кода приложения — это обычный пример <a href="http://martinfowler.com/bliki/ParallelChange.html">Parallel Change</a>.</p><br/>
<p>4) Сервер CI обнаруживает изменения в mainline и начинает новую сборку, которая содержит миграцию базы данных.</p><br/>
<p>5) Сервер CI использует свою копию базы данных для сборки, поэтому применяет скрипт миграции базы данных к этой базе данных, чтобы произвести изменения в миграции. Кроме того, он запускает остальные шаги сборки: компилирование, модульные тесты, функциональные тесты и подобные.</p><br/>
<p>6) После того, как сборка успешно завершается, сервер CI пакетирует артефакты сборки и передаёт их. Артефакты сборки содержат скрипты миграции базы данных, для применения их к базам данных в downstream средах, таких как Deployment Pipeline. Артефакты сборки также содержат код приложения, пакетированный в jar, war, dll и другие.</p><br/>
<p>Именно такой метод непрерывной интеграции обычно используется в управлении исходным кодом приложения. Вышеуказанные шаги показывают что код базы данных рассматривается как часть исходного кода. Подобный код БД — DDL, DML, Data, выборки, события, запускающие процедуру, хранимые процедуры — находятся под управлением конфигурации, так же как и исходный код. Каждый раз, когда происходит успешная сборка, собирая артефакты БД и артефакты приложения в единое, мы получаем полную синхронизированную историю версий как приложений, так и баз данных.</p><br/>
<p>Имея исходный код приложения, большую часть мучений от интеграции с изменениями можно ликвидировать, если использовать системы управления исходным кодом и различные тесты в локальных средах. В отношении баз данных усилий применяется немного больше, потому что в базе данных есть данные (состояния), которые должны сохранять своя бизнес логика. (Мы поговорим подробнее об автоматизированном рефакторинге базы данных позже). Кроме того, администратор БД должен следить за любыми изменениями БД и убеждаться, что они вписываются в общую картину схемы базы данных и архитектуру данных. Чтобы всё это чётко работало, крупные изменения не должны быть сюрпризом в момент интеграции, поэтому администраторам нужно теснее сотрудничать с разработчиками.</p><br/>
<p>Мы настаиваем на более частых интеграциях, потому что поняли, что гораздо проще делать множество небольших интеграций, а не редкие крупные, это тот случай, когда <a href="http://martinfowler.com/bliki/FrequencyReducesDifficulty.html">Частота Снижает Сложность</a>. Муки от интеграции растут экспоненциально с увеличением объёма интеграции, так что множество небольших изменений оказываются намного легче на практике, даже если это кажется многим нелогичным.</p><br/>
<h3 id="baza-dannyh-sostoit-iz-shemy-i-dannyh">База данных состоит из схемы и данных</h3><br/>
<p>Когда мы говорим о базе данных, мы подразумеваем не только схему базы данных и её код, но и значительное количество данных. Эти данные состоят из обычных обязательных данных приложения, таких как неизменный список всех государств, стран, валют, типов адресов и различных специфических данных. Мы также можем включить некоторые образцы тестовых данных, например, несколько шаблонов клиентов, заказов и т.д. Эти данные-образцы не попадут в production, если только специально не потребуются для теста работоспособности или семантического мониторинга.</p><br/>
<p>Эти данные существуют по нескольким причинам. Основная причина — запуск тестирования. Мы преданные поклонники использования внушительного набора автоматизированных тестов, для стабилизации разработки приложения. Такой набор тестов — распространённый подход гибких методов. Чтобы такие тесты проходили эффективно, имеет смысл работать над базой данных, которая заполнена тестовой информацией, которую все тесты ожидают увидеть.</p><br/>
<p>Эти образцы данных должны управляться версиями, чтобы знать, где их найти, когда понадобится заполнить новую базу данных, поэтому у нас есть запись изменений, которая синхронизируется с тестами и кодом приложения.</p><br/>
<p>Образец тестовых данных позволяет тестировать миграции, когда меняется схема базы данных и помогает тестировать код. Когда есть тестовые данные, мы просто вынуждены следить за тем, что любые изменения схемы также обрабатывают образцы данных.</p><br/>
<p>В большинстве проектов, которые мы видели, эти образцы данных были фиктивными. Но попалось несколько проектов, где использовались реальные данные. В этих случаях данные были извлечены из предшествовавших унаследованных систем с автоматизированными скриптами преобразования данных. Очевидно, что конвертировать все данные сразу же невозможно, потому что в ранних итерациях собирается только маленькая часть новой базы данных. Но мы можем использовать <a href="http://martinfowler.com/bliki/IncrementalMigration.html">Incremental Migration</a> для разработки скриптов преобразования и получить необходимые данные вовремя.</p><br/>
<p>Это не только поможет избавиться от проблем преобразования данных на ранних этапах, это упростит работу с растущей системой узким специалистам, поскольку они знакомы с данными, на которые они смотрят, и часто могут помочь выявить скрипты, вызывающие проблемы с базами данных и архитектурой приложений. В результате мы пришли к выводу, что нужно пытаться вводить реальные данные с самой первой итерации проекта. <a href="http://jailer.sourceforge.net/">Jailer</a> показался нам полезным инструментом в таком процессе.</p><br/>
<h3 id="vse-izmeneniya-bazy-dannyh---eto-refaktoring-bazy-dannyh">Все изменения базы данных — это рефакторинг базы данных</h3><br/>
<p>Изменения, которые мы делаем в базе данных, меняют способ хранения в ней информации, устанавливают новые способы хранения или удаляют хранилище, которое больше не нужно. Но ни одно из изменений базы данных, само по себе, не меняет общее поведение приложения. Следовательно, мы можем рассматривать их как подходящие под определение рефакторинга.</p><br/>
<blockquote>изменение, внесенное во внутреннюю структуру программы, которое делает его более понятным и легко изменяемым, без изменения его наблюдаемого поведения <br/>
<ul>
<li><a href="http://martinfowler.com/books/refactoring.html">Рефакторинг (часть 2)</a></li>
</ul><br/>
</blockquote><p>Признавая это, мы собрали и задокументировали множество рефакторингов. Составляя каталог, мы предлагаем облегчённые пути для корректных изменений, так как мы можем следовать шагам, которые мы успешно делали раньше.</p><br/>
<p>Одно из самых заметных различий в рефакторингах базы данных в том, что они включают три различных изменения, которые должны протекать одновременно.</p><br/>
<ul>
<li>Изменение схемы базы данных</li>
<li>Миграция данных в базе данных</li>
<li>Изменение кода доступа к базе данных</li>
</ul><br/>
<p>Таким образом, когда мы описываем рефакторинг базы данных, мы должны описать все три аспекта изменений и убедиться, что все три применяются, перед тем как применять другие рефакторинги.</p><br/>
<p>Как и рефакторинг кода, рефакторинги базы данных очень маленькие. Идея сбора групп маленьких изменений в последовательности, точно такая же как и в случае с кодом. Трехмерный характер изменений делает такую практику более важной.</p><br/>
<p>Многие рефакторинги базы данных, вроде <a href="http://databaserefactoring.com/IntroduceNewColumn.html">добавить новую колонку</a>, можно делать без обновления всего кода, имеющего доступ к системе. Если код станет использовать новую схему, не зная об этой схеме, колонка просто не будет использоваться. У многих изменений, правда, нет такого свойства и мы называем их <strong>деструктивными</strong>. <strong>Деструктивным изменениям</strong> нужно немного больше внимания, степень которого зависит от степени деструктивности.</p><br/>
<p>Примером незначительного деструктивного изменения служит <a href="http://databaserefactoring.com/MakeColumnNonNullable.html">сделать колонку non nullable</a>, которое превращает колонку, допускающую значение null, в не допускающую такое значение. Деструктивное оно потому, что если любой существующий код не установит её значение, то мы получим сообщение об ошибке. У нас также возникнут проблемы, если в существующих данных присутствуют null.</p><br/>
<p>Мы можем избежать проблем с существующими нулями (ценой немного других проблем), присваивая базовые данные любым рядам, содержащим нули. Для проблемы не присвоения (или присвоения нуля) у нас есть два варианта. Один из них установить для колонки значение по умолчанию.</p><br/>
<pre><code class="sql">ALTER TABLE customer
  MODIFY last_usage_date DEFAULT sysdate;

UPDATE customer
  SET last_usage_date =
    (SELECT MAX(order_date) FROM order
      WHERE order.customer_id = customer.customer_id)
  WHERE last_usage_date IS NULL;

UPDATE customer
  SET last_usage_date = last_updated_date
  WHERE last_usage_date IS NULL;

ALTER TABLE customer
  MODIFY last_usage_date NOT NULL;</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Другой — менять код приложения во время рефакторинга. Мы предпочитаем такой вариант, если можем гарантированно иметь доступ ко всему коду, который обновляет базу данных, что обычно легко сделать, если база данных используется только одним приложением, и трудно, если она общая.</p><br/>
<p>Более сложный случай — <a href="http://databaserefactoring.com/SplitTable.html">разделение таблицы</a>, в частности, если доступ к таблице раскидан по всему коду приложения. Если случай именно такой, нужно чтобы все знали, что скоро будет изменение и могли подготовиться к нему. Обдуманным поступком будет подождать сравнительно спокойного момента, например, начала итерации.</p><br/>
<p>Любое деструктивное изменение намного проще, если доступ к базе данных проложен через несколько модулей системы. Так легче найти и обновить код доступа к базе данных.</p><br/>
<p>В общем, самое главное выбрать процедуру, оптимальную именно для того вида изменений, которые делаете вы. Если сомневаетесь, попробуйте перейти на сторону упрощения изменений. По опыту мы обжигались реже, чем думают другие, и имея строгое конфигурационное управление всей системой не трудно откатиться назад, в случае самого страшного сценария.</p><br/>
<h3 id="faza-perehoda">Фаза перехода</h3><br/>
<p>Мы уже упоминали те трудности, которые появляются, когда мы сталкиваемся с деструктивным рефакторингом базы данных и не можем легко изменить код доступа. У этих проблем растут рога и клыки, когда у вас база данных общая и, возможно, её использует множество приложений и отчетов. В таком случае вам нужно серьёзнее позаботиться о чём-то, вроде <a href="http://databaserefactoring.com/RenameTable.html">переименовании таблицы</a>. Чтобы обезопасить себя от рогатых проблем, обратимся к фазе перехода.</p><br/>
<p><strong>Фаза перехода</strong> — это период времени, когда база данных одновременно поддерживает и старый шаблон доступа, и новые. Это даёт более старым системам время мигрировать на новые структуры с их собственной скоростью. (Забота об изменениях в базе данных, включая DDL, DML и миграции данных в процессе разработки, обеспечивает максимальный смысл для группы данных, избегая пакетной миграции всех изменений группы данных во время деплоя без контекста.)</p><br/>
<p><br/>
<em>Рис 8: Рефакторинг базы данных, применённый к унаследованной базе данных и фазы, которые она должна пройти перед реализацией </em></p><br/>
<pre><code class="sql">ALTER TABLE customer RENAME to client;

CREATE VIEW customer AS
SELECT id, first_name, last_name FROM client;</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Для примера с <a href="http://databaserefactoring.com/RenameTable.html">переименованием</a>, разработчик может создать скрипт, который переименовывает таблицу customer в таблицу client, а также создает выборку customer, которую могут использовать существующие приложения. Это <a href="http://martinfowler.com/bliki/ParallelChange.html">параллельное изменение</a> поддерживает новый и старый доступ. Правда он добавляет сложность, поэтому важно его удалить когда придёт время миграции в downstream системы. В некоторых компаниях это можно сделать за несколько месяцев, а в некоторых такое может занять годы.</p><br/>
<p>Выборки – это один метод для осуществления фаз перехода. Мы также используем переключающие события базы данных, которые удобны для таких случаев, как <a href="http://databaserefactoring.com/RenameColumn.html">переименование колонки</a>.</p><br/>
<h3 id="avtomatizaciya-refaktoringov">Автоматизация рефакторингов</h3><br/>
<p>Поскольку рефакторинг стал популярным для кода приложения, многие языки получили хорошую поддержку для автоматических рефакторингов. Автоматизация упрощает и ускоряет рефакторинг быстрым выполнением различных шагов без вмешательства человека и поэтому исключает человеческие ошибки. Такая автоматизация также существует для баз данных. Фреймфорки вроде <a href="http://liquibase.org/">LiquiBase</a> и <a href="http://guides.rubyonrails.org/active_record_migrations.html">Active Record Migrations</a> позволяют использовать DSL для применения рефакторингов базы данных, что позволяет применять миграции баз данных стандартным способом.</p><br/>
<p>Но такие виды стандартизированных рефакторингов не слишком подходят для баз данных, так как правила работы с миграцией данных и унаследованными данными очень сильно зависят от специфической практики команды. А мы предпочитаем проводить рефакторинг базы данных с помощью скриптов миграции и фокусируемся на инструментах автоматизации.</p><br/>
<p>Мы пишем каждый скрипт, как вы видели, объединяя SQL DDL (для изменения схемы) и DML (для миграции данных) и помещаем результат в репозиторий. Автоматизация у нас гарантирует, что мы никогда не применим эти изменения вручную, только с помощью инструментов автоматизации. Таким способом мы поддерживаем порядок рефакторингов и обновляем метаданные базы данных.</p><br/>
<p>Мы можем применять эти рефакторинги к любому состоянию базы данных, чтобы держать их синхронизированными с последней рабочей или любой предыдущей версией. Инструмент использует метаинформацию из базы данных, чтобы узнать её текущую версию, а затем применяет каждый рефакторинг между найденной и требуемой версией. Мы можем использовать этот подход для обновления версий разработки, версий тестирования и баз данных в production.</p><br/>
<p>Обновление БД в production ничем не отличается от тестирования БД, мы применяем один и тот же набор скриптов к различным данным. Мы предпочитаем делать частые релизы, тогда обновления остаются мелкими, а значит протекают значительно быстрее и решать любые возникающие проблемы легче. Самый простой способ делать эти обновления, отключать БД production пока обновления применяются, это работает в большинстве ситуаций. Можно применять обновления и при активной БД, но о методах такого подхода придётся написать отдельную статью.</p><br/>
<p>Кроме автоматизации предстоящих изменений, можно обдумать возможность автоматизации обратных изменений для каждого рефакторинга. В этом случае у вас будет возможность обратить изменения в базе данных таким же автоматизированным способом. Мы не доказали экономическую эффективность и достаточную пользу этой методики, к тому же, в ней не оказалось острой потребности, но тут работает тот же самый основной принцип. Обычно мы стараемся писать миграции так, чтобы фрагмент доступа к БД мог работать как со старой так и с новой версией базы данных. Это позволяет обновлять БД, поддерживая будущие потребности и держать её в активном состоянии, оставлять её запущенной в production, и только потом, как только мы увидим, что всё работает без проблем, загружать обновление, которое использует новые структуры данных.</p><br/>
<p>Инструментов, которые автоматизируют применение миграций БД, сегодня много, среди них Flyway, LiquiBase, миграции MyBatis, DBDeploy. Вот применение миграции с Flyway.</p><br/>
<pre><code class="bash">psadalag:flyway-4 $ ./flyway migrate
Flyway 4.0.3 by Boxfuse

Database: jdbc:oracle:thin:@localhost:1521:xe (Oracle 11.2)
Successfully validated 9 migrations (execution time 00:00.021s)
Creating Metadata table: "JEN_DEV"."schema_version"
Current version of schema "JEN_DEV": &lt;&lt; Empty Schema &gt;&gt;
Migrating schema "JEN_DEV" to version 0 - base version
Migrating schema "JEN_DEV" to version 1 - asset
Migrating schema "JEN_DEV" to version 2 - asset type
Migrating schema "JEN_DEV" to version 3 - asset parameters
Migrating schema "JEN_DEV" to version 4 - inventory
Migrating schema "JEN_DEV" to version 5 - split inventory
Migrating schema "JEN_DEV" to version 6 - equipment type
Migrating schema "JEN_DEV" to version 7 - add insurance value to equipment type
Migrating schema "JEN_DEV" to version 8 - data location equipment type
Successfully applied 9 migrations to schema "JEN_DEV" (execution time 00:00.394s).
psadalag:flyway-4 $ </code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<h3 id="razrabotchiki-mogut-obnovlyat-svoi-bazy-dannyh-po-trebovaniyu">Разработчики могут обновлять свои базы данных по требованию.</h3><br/>
<p>Как объяснялось выше, первый шаг интеграции изменений в mainline — извлечь любые изменения, случившиеся пока мы выполняли свою часть работы. Это не только основная часть стадии интеграции, она часто бывает полезной, перед тем, как мы закончим, потому что тогда мы сможем оценить влияние любых изменений, о которых говорили коллеги. В обоих случаях главное — иметь возможность легко вытащить изменения из mainline и применить их к своей локальной базе данных.</p><br/>
<p>В начале мы пуллим изменения в своё рабочее пространство. Обычно это довольно просто, но иногда оказывается, что кто-то из коллег загрузил миграцию в mainline пока мы работали над своей. Если мы писали миграцию с идентификатором 8, мы увидим как другая миграция с этим же номером появится в папке миграций. Инструмент миграции должен это обнаружить.</p><br/>
<pre><code class="bash">psadalag:flyway-4 $ ./flyway migrate
Flyway 4.0.3 by Boxfuse

Database: jdbc:oracle:thin:@localhost:1521:xe (Oracle 11.2)
ERROR: Found more than one migration with version 8
Offenders:
-&gt; /Users/psadalag/flyway-4/sql/V8__data_location_equipment_type.sql (SQL)
-&gt; /Users/psadalag/flyway-4/sql/V8__introduce_fuel_type.sql (SQL)
psadalag:flyway-4 $</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Как только мы заметим конфликт, первый шаг будет простым: нам нужно перенумеровать свою миграцию в 9, тогда она переприменится поверх новой миграции в mainline. После перенумерации нужно протестировать существующие миграции на конфликт. Для этого нужно почистить базу данных, а потом применить все миграции, включая новую 8 и свою перенумерованную 9 к пустой копии БД.</p><br/>
<pre><code class="sql">psadalag:flyway-4 $ mv sql/V8__introduce_fuel_type.sql sql/V9__introduce_fuel_type.sql
psadalag:flyway-4 $ ./flyway clean
Flyway 4.0.3 by Boxfuse

Database: jdbc:oracle:thin:@localhost:1521:xe (Oracle 11.2)
Successfully cleaned schema "JEN_DEV" (execution time 00:00.031s)
psadalag:flyway-4 $ ./flyway migrate
Flyway 4.0.3 by Boxfuse

Database: jdbc:oracle:thin:@localhost:1521:xe (Oracle 11.2)
Successfully validated 10 migrations (execution time 00:00.013s)
Creating Metadata table: "JEN_DEV"."schema_version"
Current version of schema "JEN_DEV": &lt;&lt; Empty Schema &gt;&gt;
Migrating schema "JEN_DEV" to version 0 - base version
Migrating schema "JEN_DEV" to version 1 - asset
Migrating schema "JEN_DEV" to version 2 - asset type
Migrating schema "JEN_DEV" to version 3 - asset parameters
Migrating schema "JEN_DEV" to version 4 - inventory
Migrating schema "JEN_DEV" to version 5 - split inventory
Migrating schema "JEN_DEV" to version 6 - equipment type
Migrating schema "JEN_DEV" to version 7 - add insurance value to equipment type
Migrating schema "JEN_DEV" to version 8 - data location equipment type
Migrating schema "JEN_DEV" to version 9 - introduce fuel type
Successfully applied 10 migrations to schema "JEN_DEV" (execution time 00:00.435s).
psadalag:flyway-4 $</code><div class="code-explainer"><a href="https://sourcecraft.dev/" class="tm-button code-explainer__link" style="visibility: hidden;"></a></div></pre><br/>
<p>Обычно это работает на ура, но периодически случаются конфликты, просто потому, что кто-то из разработчиков переименовал таблицу, в которую мы вносили изменения. В таком случае нужно выяснить, как разрешить конфликт. Тут и открывается ценность небольших миграций: с ними легче обнаружить и разобраться с конфликтами.</p><br/>
<p>Как только изменения базы данных интегрированы, нужно повторно запустить пакет тестов, на случай, если миграция из mainline приведёт к поломке какого-нибудь теста.</p><br/>
<p>Эта процедура позволяет нам работать независимо друг от друга короткими промежутками, даже без подключения к сети, а затем интегрировать, когда нам это удобно. Когда и как часто мы делаем эту интеграцию, полностью зависит от нас, при условии, что мы синхронизировались перед загрузкой в mainline.</p><br/>
<h3 id="chyotko-razdelit-ves-kod-dostupa-k-baze-dannyh">Чётко разделить весь код доступа к базе данных</h3><br/>
<p>Для того, чтобы понять последствия рефакторингов базы данных, нужно видеть, как база данных используется приложением. Если SQL разбросан как попало по базе исходного кода, это сделать очень трудно. Поэтому очень важно иметь чистый уровень доступа к базе данных, показывающий где и как она использовалась. Для этого мы советуем следовать одному из структурных паттернов хранилища данных из книги <a href="http://www.martinfowler.com/books/eaa.html">Patterns of Enterprise Application Architecture</a>.</p><br/>
<p>Наличие чистого уровня базы данных имеет несколько ценных побочных преимуществ. Он минимизирует количество блоков в системе, управлять которыми могут только разработчики со знанием SQL, и облегчает жизнь тем разработчикам, которые часто не слишком квалифицированны в SQL. Администратору он даёт чистый блок кода, в котором тот может увидеть, как использовалась база данных. Это помогает подготавливать индексы, оптимизировать базу данных, и рассматривать SQL, чтобы понять, как её можно изменить для лучшей работы. Это позволяет администратору базы данных лучше понимать, как используется база данных.</p><br/>
<h3 id="delayte-bolshe-relizov">Делайте больше релизов</h3><br/>
<p>Когда мы писали первую версию этой статьи более десяти лет назад, концепция более частого релиза софта имела мало поддержки. Но рост интернет-гигантов показал, что частые релизы — ключевая часть успешной стратегии цифровой индустрии.</p><br/>
<p>Для каждого изменения зафиксированного в миграции, мы можем легко задеплоить новые изменения в тестовой и production среде. Тот тип эволюционного проектирования баз данных, который мы обсуждаем здесь, одновременно позволяет делать частые релизы, а также извлекает пользу из фидбека, получаемого от реального использования софта.</p><br/>
<h2 id="variacii">Вариации</h2><br/>
<p>Как и любой другой набор методов, они должны быть разнообразными в зависимости от обстоятельств, вот некоторые из тех, с которыми столкнулись мы.</p><br/>
<h3 id="neskolko-versiy">Несколько версий</h3><br/>
<p>Простой проект может выжить только с единственной веткой, а значит, одной версией базы данных. В более сложных проектах нужна поддержка нескольких версий для AB тестирования или запуска деплоев когда происходят <a href="http://martinfowler.com/bliki/CanaryRelease.html">Canary Releases</a> и, следовательно, нескольких разновидностей баз данных проекта. Каждому релизу могут требоваться свои тестовые данные, изменения для тестирования конкретного компонента или исправление определенных багов. Это ничем не отличается от управления несколькими версиями кода production, но с небольшой изюминкой, суть которой в том, что база данных должна поддерживать несколько релизов приложения.</p><br/>
<p>Ещё один метод, который мы считаем полезным — единый репозиторий для базы данных и всех остальных версий приложения, зависящих от репозитория базы данных. Вам нужно контролировать, что все версии кода работают с той же версией базы данных, а значит, форсировать базу данных иметь обратную совместимость со всеми предыдущими версиями приложений, которые находятся в production.</p><br/>
<h3 id="dostavka-izmeneniy-s-prilozheniem">Доставка изменений с приложением</h3><br/>
<p>В некоторых проектах мы уже видели, что изменения применённые к продукту должны быть распространены среди тысяч конечных потребителей. В таких видах проектов лучше давать приложению обновлять себя самому, пакетированием всех изменений базы данных вместе с приложением (потому что мы не имеем даже примерного представления с какой версии обновляется клиент), и дать приложению обновить базу данных при запуске, используя фреймворки, например, <a href="http://flywaydb.org/">Flyway</a> или один из его многочисленных подобий.</p><br/>
<h3 id="neskolko-prilozheniy-ispolzuyuschih-odnu-bazu-dannyh">Несколько приложений, использующих одну базу данных</h3><br/>
<p>Во многих корпорациях множество приложений оказываются в итоге с одной общей базой данных — <a href="http://enterpriseintegrationpatterns.com/SharedDataBaseIntegration.html">паттерн интеграции Shared Database</a>. В таких ситуациях, когда одно приложение вносит изменение в базу данных, вполне вероятно, что изменение сломает другие приложения. Чтобы избежать этого, лучше извлечь базу данных, которая используется всеми зависимыми приложениями, в виде отдельного репозитория кода. Этот общий репозиторий базы данных должен быть покрыт <a href="http://sadalage.com/blog/2015/08/16/behavior-driven-database-development/">автоматизированными поведенческими тестами</a>, которые дают уверенность, что перекрестные зависимости приложений протестированы, и останавливать сборку, если зависимые приложения затронуты. Это не отличается от варианта, когда есть расшаренный программный компонент, со своим хранилищем кода. </p><br/>
<h3 id="nosql-bazy-dannyh">NoSQL базы данных</h3><br/>
<p>Наша статья концентрируется на реляционных базах данных отчасти потому, что оригинал был о них, и отчасти потому, что до сих пор мы убеждаемся в их большей распространённости. И мы, можно сказать, знакомы с NoSQL базами данных, которые в последнее время стали более распространёнными. Полноценное обсуждение того, как их обслуживать эволюционным путем, тянет на ещё одну статью, но мы попытаемся дать им поверхностный обзор.</p><br/>
<p>Базы данных NoSQL заявлены как инструменты лучше приспособленные к эволюционному пути, поскольку большинство из них "бессхемные". Но их бессхемность не избавляет нас от необходимости обсуживать схемы, поскольку неявная схема в них существует. Любой код, имеющий доступ к базе данных, косвенно выражает такую схему. Этой схемой нужно управлять, фактически используя те же методы миграции данных в репозитории исходного кода. Отсутствие схемы хранения даёт нам другую технику для поддержания нескольких стратегий чтения разных версий. Это может упростить управление эволюцией баз данных, но нам всё ещё есть о чём беспокоиться.</p><br/>
<h2 id="vam-ne-nuzhna-armiya-administratorov-bd">Вам не нужна армия администраторов БД</h2><br/>
<p>Использование перечисленных методов по ощущениям требует много работы, но по факту не требует гигантского коллектива. Во многих проектах у нас было по тридцать с лишним разработчиков, а во всей команде (включая QA, аналитиков и управляющих) было около сотни сотрудников. В любой день у нас появлялось около сотни экземпляров различных схем, собранных на персональных рабочих станциях. При этом вся активность требовала одного полного рабочего дня администратора и нескольких разработчиков, понимающих рабочий процесс и последовательность, которые выполняли бы частичную поддержку и проверку.</p><br/>
<p>В небольших проектах не требуется даже такое. Мы использовали такие методы в небольших проектах (около десятка человек), и поняли, что в полном рабочем дне администратора нет необходимости. Вместо этого мы полагаемся на пару разработчиков, любопытных к проблемам БД, которые выполняют задачи администратора парт-тайм и, в случае необходимости, привлекаем администраторов, чтобы принять решение по дизайну или архитектуре.</p><br/>
<p>Это возможно благодаря автоматизации. Если вы решили автоматизировать все задачи, вы можете выполнять много работы, не задействуя большого количества людей. Особенно когда такие инструменты как DevOps и похожие (Puppet, Chef, Docker, Rocket, and Vagrant) стали популярными.</p><br/>
<p>С тех пор, как мы работаем в этом стиле много лет, мы решили полагаться на базы данных, которые могут эволюционировать так же, как код приложения, учащать циклы релизов и двигать софт в production быстрее. Описанные методы теперь — часть нашего привычного способа работы. Но наша цель не только улучшить собственные методы, но и поделиться своим опытом с программной индустрией. Чем больше подобных техник осваивают другие, тем больше софта реализует потребности людей, а прогресс, который достигается с помощью такого софта обогащает жизнь в целом.</p><br/>
<p><em>(Перевод <a href="https://www.instagram.com/minotauria/">Наталии Басс</a>)</em></p></div></div></div><!----><!----></div><!----><!----></div><!--]--><!----><div class="tm-article-presenter__meta" data-test-id="article-meta-links"><div class="tm-separated-list tag-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D0%B1%D0%B4]" class="link"><span>бд</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[agile]" class="link"><span>agile</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0]" class="link"><span>разработка</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD+%D0%B1%D0%B4]" class="link"><span>дизайн бд</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[dba]" class="link"><span>dba</span></a><!--]--></li><!--]--><!----></ul></div><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/analysis_design/" class="link"><!--[--><span>Анализ и проектирование систем</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/refactoring/" class="link"><!--[--><span>Проектирование и рефакторинг</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/industrial_control_system/" class="link"><!--[--><span>Промышленное программирование</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/cvs/" class="link"><!--[--><span>Системы управления версиями</span><!--]--></a><!--]--></li><!--]--><!----></ul></div></div><!----><!--]--></article><!--]--></div><!----></div><div style="" class="tm-article-sticky-panel" data-test-id="article-sticky-panel"><div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons"><div class="article-rating tm-data-icons__item" data-v-b9b05a90><div class="tm-votes-meter votes-switcher" data-v-b9b05a90><svg class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article" height="24" width="24"><title>Всего голосов 28: ↑26 и ↓2</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-rating"></use></svg><span class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating tm-votes-meter__value" data-test-id="votes-meter-value" title="Всего голосов 28: ↑26 и ↓2">+22</span></div><!--teleport start--><!--teleport end--><!----></div><!----><!----><button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button" data-v-861e2740><span class="tm-svg-icon__wrapper icon" data-v-861e2740><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Добавить в закладки</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-favorite"></use></svg></span><span class="counter" title="Количество пользователей, добавивших публикацию в закладки" data-v-861e2740>109</span></button><div class="sharing tm-data-icons__item" title="Поделиться" data-v-daf6ee1d><button class="sharing-button" type="button" data-v-daf6ee1d><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="icon" data-v-daf6ee1d><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button><!--teleport start--><!--teleport end--></div><div class="article-comments-counter-link-wrapper tm-data-icons__item" title="Читать комментарии" data-v-8d952463><a href="/ru/articles/312970/comments/" class="article-comments-counter-link" data-test-id="counter-comments" data-v-8d952463><!--[--><svg class="tm-svg-img icon" height="24" width="24" data-v-8d952463><title>Комментарии</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-comments"></use></svg><span class="value" data-v-8d952463>0</span><!--]--></a><!----></div><!--[--><!--[--><!--[--><!----><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!----></div></div></div><!--[--><!--]--><div class="tm-article-presenter__footer"><!--[--><!--[--><div class="tm-article-blocks"><!----><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><!----><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><!--[--><div class="article-author" data-test-id="article-author-info" data-async-called="true" data-v-af0d0f90><!--[--><!--]--><div class="tm-user-card tm-user-card tm-user-card_variant-article user-card" data-async-called="true" data-v-af0d0f90><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/freetonik/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><!--[--><div class="tm-entity-image"></div><!--]--></a><div class="tm-user-card__meta"><div class="tm-counter-container karma" title=" 851 голос " data-v-544d285f><div class="tm-counter-container__header"><!--[--><div class="karma-display positive" data-v-544d285f data-v-3881f4ba>647</div><!----><!--]--></div><div class="tm-counter-container__footer"><!--[--><div class="karma-text" data-v-544d285f>Карма</div><!--teleport start--><!--teleport end--><!--]--></div></div><div class="tm-counter-container"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!----><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score" data-test-id="lever-score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">0</span></span><!--]--></div><!----></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Общий рейтинг</span><!--]--></div></div></div></div></div><div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info"><div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title"><span class="tm-user-card__name tm-user-card__name_variant-article tm-user-card__name">Рахим Давлеткалиев</span><a href="/ru/users/freetonik/" class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article"><!--[-->@freetonik<!--]--></a><!----></div><p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">Пользователь</p></div></div><!----><div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons"><!----><div class="tm-user-card__button"><div class="tm-button-follow tm-user-card__button-follow"><!----><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div></div><!----><!--[--><div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations"><svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16"><title>Отправить сообщение</title><use xlink:href="/img/megazord-v28.cba4c116..svg#mail"></use></svg></div><!--]--><!----><!----></div><!----></div><div class="author-contacts" data-test-id="author-contacts" data-v-af0d0f90><!----><!----><!--[--><a class="contact" data-test-id="author-contact-link" href="https://rakh.im" rel="noopener" target="_blank" data-v-af0d0f90>Сайт</a><a class="contact" data-test-id="author-contact-link" href="https://x.com/freetonik" rel="noopener" target="_blank" data-v-af0d0f90>X</a><a class="contact" data-test-id="author-contact-link" href="https://github.com/freetonik/" rel="noopener" target="_blank" data-v-af0d0f90>GitHub</a><a class="contact" data-test-id="author-contact-link" href="https://instagram.com/freetonik/" rel="noopener" target="_blank" data-v-af0d0f90>Instagram</a><!--]--></div></div><!--]--></div><!--]--><!----></section><!----><!--[--><div class="sponsor-block" style="--d75346b8:0;--11dbf66e:100%;" data-v-580b3119><div class="title" data-v-580b3119>Хабр доступен 24/7 благодаря поддержке друзей</div><div class="content-container" data-v-580b3119><div class="content" data-v-580b3119><div class="content-title-container" data-v-580b3119><div class="content-title" data-v-580b3119>Хабр Курсы для всех</div><div class="sponsor-mark" data-v-580b3119>РЕКЛАМА</div></div><div class="content-text" data-v-580b3119> Практикум, Хекслет, SkyPro, авторские курсы — собрали всех и попросили скидки. Осталось выбрать! </div><a class="content-action" href="https://career.habr.com/courses/?erid=2VSb5wDLYUH&amp;utm_source=habr&amp;utm_medium=sponsorship_hub" target="_blank" data-v-580b3119><button class="btn btn_solid btn_small tm-button_color-horizon" tabindex="0" type="button" data-v-580b3119><!--[--><!--[-->Перейти<!--]--><!--]--></button></a></div></div><div class="footer" data-v-580b3119><!----></div><!----></div><!--]--><!--]--><div class="tm-article-blocks__comments"><div id="publication-comments" class="tm-article-page-comments"><div><!--[--><div class="article-comments-counter-link-wrapper tm-article-comments-counter-button" data-v-8d952463><a href="/ru/articles/312970/comments/" class="article-comments-counter-link button-style" data-test-id="counter-comments" data-v-8d952463><!--[--><svg class="tm-svg-img icon icon--contrasted" height="24" width="24" data-v-8d952463><title>Комментарии</title><use xlink:href="/img/megazord-v28.cba4c116..svg#counter-comments"></use></svg><span class="value value--contrasted" data-v-8d952463> Комментировать </span><!--]--></a><!----></div><!--]--></div></div></div><!--[--><!--[--><!--]--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]--></div><!----></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim"><!--[--><!--[--><div class="tabs" data-test-id="container" data-v-681e7545><div class="" data-test-id="scroll-area" data-v-681e7545><!--[--><span class="tab-item" data-v-681e7545><button class="active slim tab-link" data-v-681e7545>Лучшие за сутки</button></span><span class="tab-item" data-v-681e7545><button class="slim tab-link" data-v-681e7545>Похожие</button></span><!--]--></div><!----></div><div class="similar-and-daily__tab-view"><div class="daily-articles-list"><ul class="article-card-list" data-v-7f7081d6><!--[--><!--]--><div class="tm-bordered-card" data-v-7f7081d6><!----><!--[--><!--]--></div></ul><div class="daily-articles-block__button-container"><button class="btn btn_transparent btn_small tm-button_color-horizon" tabindex="0" type="button"><!--[--><!--[-->Показать лучшие за всё время<!--]--><!--]--></button></div></div><!----></div><!--]--><!--]--></div><!--]--><!----></section><!--[--><div><div class="placeholder-wrapper"><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="tm-placeholder-promo"><div class="tm-placeholder-promo__header"><div class="tm-placeholder__line tm-placeholder__line_promo-title"></div></div><div class="tm-placeholder-promo__body"><div class="tm-placeholder-promo__posts"><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div></div><div class="tm-placeholder-promo__dots"><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div></div></div></div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----></div></div><div class="placeholder-wrapper"><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="tm-placeholder-inset tm-placeholder-questions"><div class="tm-placeholder-inset__header"><div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div></div><div class="tm-placeholder-inset__body"><ul class="tm-placeholder-list"><!--[--><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><!--]--></ul></div><div class="tm-placeholder-inset__footer"><div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div></div></div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----></div><!--]--><!----><!--[--><!--]--><!--]--></div><!----><!--]--><!--]--></div></div><!--]--></div><!--]--></div></div><div class="tm-page__sidebar"><!--[--><div class="sidebar" data-v-0050f56d><div id="sidebar-window-placement" data-v-0050f56d></div><!--[--><!--]--></div><!--]--></div></div><!--]--></div><!----></div></main><!----></div><div class="tm-footer-menu"><div class="tm-page-width"><!--[--><div class="tm-footer-menu__container"><!--[--><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Ваш аккаунт</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/articles/312970/&amp;hl=ru" rel="nofollow" target="_self">Войти</a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/articles/312970/&amp;hl=ru" rel="nofollow" target="_self">Регистрация</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Разделы</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/ru/articles/" class="footer-menu__item-link">Статьи</a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">Новости</a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">Хабы</a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">Компании</a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">Авторы</a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">Песочница</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Информация</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">Устройство сайта</a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">Для авторов</a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">Для компаний</a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">Документы</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement/?hl=ru_RU" target="_blank">Соглашение</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/?hl=ru_RU" target="_blank">Конфиденциальность</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Услуги</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/corporate-blogs/" target="_blank">Корпоративный блог</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/advertising/" target="_blank">Медийная реклама</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/native-special/" target="_blank">Нативные проекты</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/education-programs/" target="_blank">Образовательные программы</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/hello-startup/" target="_blank">Стартапам</a></li><!--]--></ul></div></div><!--]--></div><!--]--></div></div><div class="tm-footer"><div class="tm-page-width"><!--[--><div class="tm-footer__container"><!----><div class="social-icons tm-footer__social" data-v-d6e8cb42><!--[--><a class="tm-svg-icon__wrapper social-icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" data-v-d6e8cb42><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>VK</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use></svg></a><a class="tm-svg-icon__wrapper social-icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" data-v-d6e8cb42><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Telegram</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a class="tm-svg-icon__wrapper social-icon" href="http://www.youtube.com/@Habr_com" rel="nofollow noopener noreferrer" target="_blank" data-v-d6e8cb42><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Youtube</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a class="tm-svg-icon__wrapper social-icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank" data-v-d6e8cb42><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Яндекс Дзен</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use></svg></a><!--]--></div><!--teleport start--><!--teleport end--><button class="tm-footer__link"><!----> Настройка языка</button><a href="/ru/feedback/" class="tm-footer__link">Техническая поддержка</a><div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2026,</span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank"> Habr </a></span></span></div></div><!--]--></div></div><!----><!----><!--]--></div><!----></div></div>
    <div id="overlays"><!--teleport start anchor--><template><!----></template><!--teleport anchor--><!--teleport start anchor--><template><!----></template><!--teleport anchor--><!--teleport start anchor--><template><!----></template><!----><!--teleport anchor--><!--teleport start anchor--><!----><!--teleport anchor--><!--teleport start anchor--><!----><!--teleport anchor--><!--teleport start anchor--><!----><!--teleport anchor--><!--teleport start anchor--><!----><!--teleport anchor--></div>
    
    
    
    
  
  
    
  
    </body>

    </html>
